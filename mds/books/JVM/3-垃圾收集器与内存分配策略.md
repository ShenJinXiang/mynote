# 垃圾收集器与内存分配策略
## 判断可回收的对象
### 引用计数算法
每当有一个地方引用对象，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能在被使用的

主流Java虚拟器没有选用引用计数算法来管理内存，最主要原因是很难解决对象之间相互循环引用的问题

### 可达性分析算法
以*GC Roots*对象为起点，从起点向下搜索，搜索走过的路径称为引用链，当GC Roots到某个对象不可达时，证明对象不可引用。

GC Roots：

* 虚拟机栈（栈帧中的本地变量表）中引用的对象
* 方法区中类静态属性引用的对象
* 方法区中常量引用的对象
* 本地方法栈中JNI（即Native方法）引用的对象

### 关于引用
引用的分类：
* 强引用：指在程序代码中普遍存在的，类似`Object obj = new Object()`这类引用，只要强引用还存在，垃圾收集器用于不会回收掉被引用的对象
* 软引用：描述一些还有用但北非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还是没有足够内存，才抛出内存溢出异常。通过`SoftReference`类实现软引用
* 弱引用：也描述非必需对象，但是强度比软引用更弱一些，被若引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联着的对象。通过`WeakReference`类实现弱引用
* 虚引用：也被称为幽灵引用或者幻影引用，是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为对象设置虚引用关联的**唯一目的就是能在这个对象被收集器回收时收到一个系统通知**，通过`PhantomReference`实现虚引用。

### 生存还是死亡
即使可达性分析算法中不可达的对象，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，进行第一次标记并且进行一次筛选（是否执行过finalize()）方法，如果对象没有覆盖finalize()或者虚拟机已经调用过一次finalize()方法，则可进行回收
