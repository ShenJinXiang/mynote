# HopSpot 虚拟机对象概要

## 对象的创建
1. 检查指令是否能在常量池中定位到一个类的符号引用
2. 检查符号引用代表的类是否已被加载、解析和初始化过
3. 为新对象分配内存    
   3.1. 所需的内存大小在类加载完成后完全确定
   3.2. 如果Java堆中内存是绝对规整的，*指针碰撞* - 移动已用内存和空闲内存之间零界点指针的位置，像空闲内存方向移动对象所需内存大小的位置
   3.3. 如果Java堆中内存不是规整的，*空闲列表* - 用于维护已用内存和空闲内存信息
   3.4. Java堆是否规整由所采用的垃圾回收器是否带有*压缩整理*功能决定的
   3.5. 分配内存需要考虑并发情况
4. 内存分配之后，分配到的内存空间都初始化为零（不包括对象头）
5. 设置对象头信息，包括对象所属类信息、类的元数据信息、对象的哈希码，对象的GC分代年龄等信息
6. 对对象信息进行初始化

## 对象的内存布局
3部分：对象头（Header）、实例数据（Instance Data）、对齐填充（Padding）

### 对象头
分为两部分：

* 存储对象自身的运行时数据

如哈希码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时时间戳等

|村粗的内容                            | 标志位|        状态      |
|:-------------------------------------|:-----:|:-----------------|
|对象哈希码、对象分代年龄              |   01  |未锁定            |
|指向锁定记录的指针                    |   00  |轻量级锁定        |
|指向重量级锁的指针                    |   10  |膨胀（重量级锁定）|
|空，不需要记录信息                    |   11  |GC标记            |
|偏向线程ID、想象时间戳、对象分代年龄  |   10  |可偏向            |

* 类型指针

即对象指向它元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例

### 实例数据
对象真正存储的数据信息，各种类型的字段内容，无论是继承还是类中定义的，都记录
longs/doubles、 ints、 shorts/chars、 bytes/booleans、 cops

* 相同宽度的字段分配到一起。
* 父类中定义的变量在子类之前

### 对齐填充
不一定存在，占位符作用。 HopSpot中 地址必须是8字节的整数倍

## 对象的访问定位
通过栈上的reference数据来操作堆上的具体对象。主流的反问方式：使用句柄、直接指针

使用句柄： java堆中划分一块内存作为句柄池，reference存储对象的句柄地址，句柄中包含了对象的实例数据和类型数据的具体地址。好处是对象移动的时候（垃圾收集时经常移动对象）,只改变句柄中的实例数据指针，reference本身不修改
直接指针： reference存储的直接就是对象地址。好处是速度更快。


