# 第2章 一切都是对象

> 如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界

**尽管Java是基于C++的，但是相比之下，Java是一种更“纯粹”的面向对象程序设计语言。**


C++和Java都是混合/杂合型语言。但是，Java的设计者认为这种杂合性并不像C++中那么重要。杂合型语言允许多种编程风格；C++之所以成为一种杂合型语言主要是因为它支持于C语言的向后兼容。因为C++是C的一个超集，所以势必包括许多C语言不具备的特性，这些特性使C++在某些方面显得过于复杂。

Java语言假设我们只进行面向对象的程序设计。也就是说，在开始用Java进行设计之前，必须将思想转换到面向对象的世界中来。这个入基本功，可以使你具备使用这样一种编程语言编程的能力，这种语言学习起来更简单，也比许多其他OOP语言更加医用。在本章，我们将看到Java程序的基本组成部分，并体会到Java中（几乎）一切都是对象。

## 2.1 用引用操纵对象
每种编程语言都有自己的操纵内存中元素的方式。有时候，程序员必须注意将要处理的数据是什么类型。你是直接操纵元素，还是用某种基于特殊语法的间接表示（如C和C++里的指针）来操纵对象？

所有这一切在Java里都得到了简化。一切都被视为对象，因此可采用单一固定的语法。尽管一切都*看作*对象，但操作的标示符实际上是对象的一个“引用”（reference）。可以将这一情形想像成遥控器（引用）来操纵电视机（对象）。只要握住这个遥控器，就能保持于电视机的连接。当有人想改变频道或减小音量时，实际操纵的是遥控器（引用），再由遥控器来调控电视机（对象）。如果想在房间里四处走走，同时仍能调控电视机，那么只需携带遥控器（引用）而不是电视机（对象）。

此外，即使没有电视机，遥控器亦可独立存在。也就是说，你拥有一个引用，并不一定需要又一个对象与它关联。因此，如果想操纵i 个词或句子，则可以创建一个`String`应用:

```java
String s;
```

但这里所创建的*只是*应用，并不是对象。如果此时想`s`发送一个消息，就会返回一个运行时错误。这是因为此时`s`实际上没有与任何事物相关联（即，没有电视机）。因此，一种安全的做法是：创建一个引用的同时便进行初始化。

```java
String s = "asdf";
```

但是这里用到了Java语言的一个特性：字符串可以使用带引号的文本初始化。通常，必须对对象采用一种更通用的初始化方法。

## 2.2 必须由你创建所有对象
一旦创建了一个引用，就希望它能与一个新的对象相关联。通常用`new`操作符来实现这一目的。`new`关键字的意思是“给我一个新对象”。所以前面的例子可以写成：

```java
String s = new String("asdf");
```

它不仅表示“给我一个新的字符串”，而且通过提供一个初始字符串，给出了*怎样*产生这个`String`的信息。

当然，除了`String`类型，Java提供了大量过剩的现成类型。重要的是，你可以自行创建类型。事实上，这是Java程序设计中一项基本行为，你会在本书以后章节中慢慢学到。

### 2.2.1 存储到什么地方
程序运行时，对象是怎么进行放置安排的呢？特别是内存是怎样分配的呢？对这些方面的了解会对你有很大的帮助。有五个不同的地方可以存储数据：

1. **寄存器** 这是最快的存储区，因为它位于不同于其他存储区的地方————处理器内部。但是寄存器的数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（另一方面，C和C++允许你向编译器建议寄存器的分配方式）
2. **堆栈**  位于通用RAM（随机访问存储器）中，但通过*堆栈指针*可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储与堆栈中————特别是对象引用，但是Java对象并不存储于其中。
3. **堆** 一种通用的内存池（也位于RAM中），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储都有很大的灵活性。当需要一个对象时，只需用`new`写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间（如果确实可以在Java中像在C++中一样在栈中创建对象）。
4. **常量存储** 常量只通常直接存放在程序代码内部，这样做是安全的，因为它们用于不会被改变。有时，在嵌入式系统中，常量本身会和其他部分割离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中。
5. **非RAM存储** 如果数据完全存活于程序之外，那么它可以不收程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是*流对象*和*持久化对象*。在流对象中，对象转化成字节流，通常被发送给另一台极其。在“持久化对象”中，对象被存放于磁盘上，因此即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可以恢复成常规的、基于RAM的对象。Java提供了对*轻量级持久化*的支持，而注入JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。

### 2.2.2 特例：基本类型
在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想像成“基本”类型。之所以特殊对待，是因为`new`将对象存储在“堆”里，故用`new`创建一个对象————特别是小的、简单的变量，往往不是很有效。因此，对于这些类型，Java采用与C和C++相同的方法。也就是说，不用`new`来创建变量，而是创建一个*并非是引用*的“自动”变量。这个变量直接存储“值”，并置于堆栈中，因此更加高效。

Java要确定每种基本类型所占存储空间的大小。它们的大小并不像其他大多数语言那样随着机器硬件架构的变化而变化。这种所占存储空间大小的不变性是java程序比用其他大多数语言编写的程序更具可移植性的原因之一。

|基本类型|大小|最小值|最大值|包装器类型|
|:--|:-|:-|:-|:-|
|boolean|-|-|-|Boolean|
|char|16-bits|Unicode 0|Unicode 2^16 - 1|Character|
|byte|8-bits|-128|+127|Byte|
|short|16-bits|-2^15|+2^15 - 1| Short|
|int|32-bits|-2^31|+2^31 - 1|Integer|
|long|64-bits|-2^63|+2^63 - 1|Long|
|float|32-bits|IEEE754|IEEE754|Float|
|double|64-bits|IEEE754|IEEE754|Double|
|void|-|-|-|Void|
