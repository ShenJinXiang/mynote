# 第5章 初始化与清理

> 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

*初始化与清理（cleanup）*正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化构建（或者是用户必须进行初始化的其他东西），更深如此。清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一只得不到释放，结果是资源（尤其是内存）用尽。

C++引入了*构造器（constructor）*的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。本章将讨论初始化和清理的相关问题，以及Java对它们提供的支持。

## 5.1 用构造器确保初始化
可以遐想为编写的每一个类都要定义一个`initialize()`方法。该方法的名称提醒你在使用其对象之前，应首先调用`initialize()`。然后，这同时意味着用户必须记得自己去调用词方法。在Java中通过提供构造器，类的设计者可确保每个对象 都会得到初始化。创建对象时，如果其类具有构造器，Java会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。

接下来的问题是如何命名这个方法。有两个问题：第一，所取的任何名字都可能与类的某个成员名称相冲突；第二，调用构造器是编译器的责任，所以必须让编译器知道应该调用哪个方法。C++语言中采用的裁决方法看来最简单且更符合逻辑，所在Java中也采用了这种方案：即构造器采用与类相同的名称。考虑到在初始化期间要自动调用构造器，这种做法就顺理成章了。

以下就是一个带有构造器的简单类：

```java
//: initialization/SimpleConstructor.java
// Demostration of a simple constructor.

class Rock {
	Rock() {
		System.out.print("Rock ");
	}
}

public class SimpleConstructor {
	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) 
			new Rock();
	}
}  /* Output:
Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock 
*///:~
```

现在，在创建对象时：
```java
new Rock();
```

将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。

请注意，由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的编码风格并不适用于构造器。

不接受任何菜蔬的构造器叫做**默认构造器**，Java文档中通常使用术语**无参构造器**，但是默认构造器在Java出现之前已经使用很多年类，所以我仍旧倾向于使用它。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。对上述例子稍加修改，即可是构造器接受一个参数：

```java
//: initialization/SimpleConstructor2.java
// Constructors can hava arguments.

class Rock2 {
	Rock2(int i ) {
		System.out.print("Rock " + i + "  ");
	}
}

public class SimpleConstructor2 {
	public static void main(String[] args) {
		for (int i = 0; i < 8; i++)
			new Rock2(i);
	}
} /* Output:
Rock 0  Rock 1  Rock 2  Rock 3  Rock 4  Rock 5  Rock 6  Rock 7  
*///:~
```

有两个构造器形式参数，就可以在初始化对象时提供实际参数。例如，假设类**Tree**有一个构造器，它接受一个整型变量来表示树的高度，就可以这样创建一个**Tree**对象。

```java
Tree t = new Tree(12); // 12-foot tree
```

如果**Tree(int)**是**Tree**类唯一的构造器，那么编译器将不会允许你以其他任何方式创建**Tree**对象。

构造器有助于减少错误，并使代码更易于阅读。从概念上将，“初始化”与“创建”是批次独立的，然后在上面的代码中，你却找不到对`initialize()`方法的明确调用。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。

构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void）冥想不同。对于空返回值，尽管方法本身不会自动返回上面，但仍可选择让它返回别的东西。构造器则不会返回任何东西，你别无选择（new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值）。假如构造器具有返回值，并且允许人们自行选择返回类型，那么势必得让编译器知道该如果处理此返回值。

## 5.2 方法重载
任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取了名字。通过使用名字，你可以引用所有的对象和方法。名字起得好可以使系统更易于理解和修改。就好比写散文————目的是让读者易于理解。

将人类语言中存在细微差别的概念“映射”到程序设计中时，问题随之而生。在日常生活中，相同的词可以表达多种不同的含义————它们被“重载”了。特别是含义之间的差别很小时，这种方式十分有用。你可以说“清洗衬衫”、“清洗车”、“清洗狗”。但如果硬要这样说就显得很愚蠢：“以洗衬衫的方式洗衬衫”、“以洗车的方式洗车”、“以洗狗的方式洗狗”。这是因为听众根本不需要对所执行的动作做出明确区分。大多数人类语言具有很强的“冗余”性，所以即使漏掉了几个词，仍然可以推断出含义。不需要对每个概念都使用不同的词汇————从具体的语境中就可以推断出含义。

大多数程序设计语言（尤其是C）要求为每个方法（在这些语言中经常称为函数）都提供一个独一无二的标识符。所以绝不能用名为`print()`的函数显示了整数之后，有用一个名为`print()`的函数显示浮点数————每个函数都要有唯一的名称。

在Java（和C++）里，构造器是强制重载方法名的另外一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造名。那么要想用更多中方式创建一个对象该怎么办呢？假设你要创建一个类，既可以用标准方法进行初始化，也可以从文件中读取信息来初始化。这就需要两个构造器：一个**默认**构造器，另一个取字符串作为形式参数————该字符串表示初始化对象所需的文件名称。由于都是构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到**方法重载**。同时、尽管方法重载是构造器所必须的，但它亦可应用与其他方法，且用法同样方便。

下面这个例子同时示范了重载的构造器和重载的方法：

```java
//: initialization/Overloading.java
// Demonstration of both constructor
// and ordinary method overloading.

class Tree {
	int height;

	Tree() {
		System.out.println("Planting a seedling");
		height = 0;
	}

	Tree(int initialHeight) {
		height = initialHeight;
		System.out.println("Creating new Tree that is " + height + " feet tall");
	}

	void info() {
		System.out.println("Tree is " + height + " feet tall");
	}

	void info(String s) {
		System.out.println(s + ": Tree is " + height + " feet tall");
	}
}

public class Overloading {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			Tree t = new Tree(i);
			t.info();
			t.info("overloaded method");
		}
		new Tree();
	}
} /* Output:
Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method: Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method: Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method: Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method: Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method: Tree is 4 feet tall
Planting a seedling
*///:~
```

创建**Tree**对象的时候，既可以不含参数，也可以用树的高度当参数。前者表示一棵树苗，后者被考试已有一定高度的树木。要支持这种创建方式，得有一个默认构造器和一个采用现有高度作为参数的构造器。

或许你还像通过多种方式调用`info()`方法。例如，你像显示额外信息，可以用`info(String)`方法；没有的化就用`info()`。要是对明显相同的概念使用了不同的名字，那一定会让人很纳闷。好在有了方法重载，可以为两者使用相同的名字。

### 5.2.1 区分重载方法
要是几个方法有相同的名字，Java如何才能知道你指的是哪一个呢？其实规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表。

稍加思考，就会觉得这是合理的。毕竟，对于名字相同的方法，处理参数类型的差异意外，还有什么办法能把它们区别开呢？

甚至参数顺序的不同也足以区分两个方法。不过，一般情况下别这么做，因为这会使代码难以维护：

```java
//: initialization/OverloadingOrder.java
// Overloading based on the order of the arguments.
public class OverloadingOrder {
	static void f(String s, int i) {
		System.out.println("String: " + s + ", int: " + i);
	}

	static void f(int i, String s) {
		System.out.println("int: " + i + ", String: " + s);
	}

	public static void main(String[] args) {
		f("String first", 11);
		f(99, "Int first");
	}
} /* Output:
String: String first, int: 11
int: 99, String: Int first
*///:~
```

上例中两个方法虽然申明了相同的参数，但顺序不同，因此得以区分。

### 5.2.2 涉及基本类型的重载
基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此过程一旦牵涉到重载，可能会造成一些混淆。以下例子说明了将基本类型传递给重载方法时发生的情况：

```java
public class PrimitiveOverloading {
	void f1(char x) { printnb("f1(char) "); }
	void f1(byte x) { printnb("f1(byte) "); }
	void f1(short x) { printnb("f1(short) "); }
	void f1(int x) { printnb("f1(int) "); }
	void f1(long x) { printnb("f1(long) "); }
	void f1(float x) { printnb("f1(float) "); }
	void f1(double x) { printnb("f1(double) "); }

	void f2(byte x) { printnb("f2(byte) "); }
	void f2(short x) { printnb("f2(short) "); }
	void f2(int x) { printnb("f2(int) "); }
	void f2(long x) { printnb("f2(long) "); }
	void f2(float x) { printnb("f2(float) "); }
	void f2(double x) { printnb("f2(double) "); }

	void f3(short x) { printnb("f3(short) "); }
	void f3(int x) { printnb("f3(int) "); }
	void f3(long x) { printnb("f3(long) "); }
	void f3(float x) { printnb("f3(float) "); }
	void f3(double x) { printnb("f3(double) "); }

	void f4(int x) { printnb("f4(int) "); }
	void f4(long x) { printnb("f4(long) "); }
	void f4(float x) { printnb("f4(float) "); }
	void f4(double x) { printnb("f4(double) "); }

	void f5(long x) { printnb("f5(long) "); }
	void f5(float x) { printnb("f5(float) "); }
	void f5(double x) { printnb("f5(double) "); }

	void f6(float x) { printnb("f6(float) "); }
	void f6(double x) { printnb("f6(double) "); }

	void f7(double x) { printnb("f7(double) "); }

	void testConstVal() {
		printnb("5: ");
		f1(5); f2(5); f3(5); f4(5); f5(5); f6(5); f7(5);
		System.out.println();
	}

	void testChar() {
		char x = 'x';
		printnb("char: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testByte() {
		byte x = 0;
		printnb("byte: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testShort() {
		short x = 0;
		printnb("short: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testInt() {
		int x = 0;
		printnb("int: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testLong() {
		long x = 0;
		printnb("long: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testFloat() {
		float x = 0;
		printnb("float: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testDouble() {
		double x = 0;
		printnb("double: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void printnb(Object obj) {
		System.out.print(obj + " ");
	}

	public static void main(String[] args){
		PrimitiveOverloading p = new PrimitiveOverloading();
		p.testConstVal();
		p.testChar();
		p.testByte();
		p.testShort();
		p.testInt();
		p.testLong();
		p.testFloat();
		p.testDouble();
	}
} /* Output
5:  f1(int)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
char:  f1(char)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
byte:  f1(byte)  f2(byte)  f3(short)  f4(int)  f5(long)  f6(float)  f7(double)  
short:  f1(short)  f2(short)  f3(short)  f4(int)  f5(long)  f6(float)  f7(double)  
int:  f1(int)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
long:  f1(long)  f2(long)  f3(long)  f4(long)  f5(long)  f6(float)  f7(double)  
float:  f1(float)  f2(float)  f3(float)  f4(float)  f5(float)  f6(float)  f7(double)  
double:  f1(double)  f2(double)  f3(double)  f4(double)  f5(double)  f6(double)  f7(double)  
*///:~
```

你会发现常数值5被当作**int**值处理，所以如果有某个重载方法接受int型参数，它就会被调用。至于其他情况，如果传入的数据类型（实际参数类型）小于方法中申明的形式参数类型，实际数据类型就会被提升，char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

如果传入的实际参数大于重载方法声明的形式参数，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。

### 5.2.3 以返回值区分重载方法
读者可能会想：“在区分重载方法的时候，为什么只能以类名和方法的形参列表作为标准呢？能否考虑用方法的返回值来区分呢？”比如下面两个方法，虽然有同样的名字和形式参数，但却很容易区分它们：

```java
void f() {}
inf f() { return 1; }
```

只要编译器可以根据语境明确判断出语义，比如在`int x = f()`中，那么的确可以据此区分重载方法。不过，有时你并不关心方法的返回值，你想要的是方法调用的其他效果（这常被成为“为了副作用而调用”），这时你可能会调用方法而忽略其返回值。所以，如果像下面只要调用方法；

```java
f();
```

此时Java如何才能判断该调用哪一个`f()`呢？别人该如何理解这种代码呢？ 因此，根据方法的返回值来区分重载方法是行不通的。

## 5.3 默认构造器
如前所述，默认构造器（又名“无参”构造器）是没有形式参数的————它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。例如：

```java
//: initialization/DefaultConstructor.java

class Bird {}

public class DefaultConstructor {
	public static void main(String[] args) {
		Bird b = new Bird(); // Default!
	}
} ///:~
```

表达式

```java
new Bird()
```

行创建了一个新对象，并调用其默认构造器————即使你没有明确定义它。没有它的话，就没有方法可调用，就无法创建对象。但是，如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器
