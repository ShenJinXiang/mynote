# 第5章 初始化与清理

> 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

*初始化与清理（cleanup）*正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化构建（或者是用户必须进行初始化的其他东西），更深如此。清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一只得不到释放，结果是资源（尤其是内存）用尽。

C++引入了*构造器（constructor）*的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。本章将讨论初始化和清理的相关问题，以及Java对它们提供的支持。

## 5.1 用构造器确保初始化
可以遐想为编写的每一个类都要定义一个`initialize()`方法。该方法的名称提醒你在使用其对象之前，应首先调用`initialize()`。然后，这同时意味着用户必须记得自己去调用词方法。在Java中通过提供构造器，类的设计者可确保每个对象 都会得到初始化。创建对象时，如果其类具有构造器，Java会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。

接下来的问题是如何命名这个方法。有两个问题：第一，所取的任何名字都可能与类的某个成员名称相冲突；第二，调用构造器是编译器的责任，所以必须让编译器知道应该调用哪个方法。C++语言中采用的裁决方法看来最简单且更符合逻辑，所在Java中也采用了这种方案：即构造器采用与类相同的名称。考虑到在初始化期间要自动调用构造器，这种做法就顺理成章了。

以下就是一个带有构造器的简单类：

```java
//: initialization/SimpleConstructor.java
// Demostration of a simple constructor.

class Rock {
	Rock() {
		System.out.print("Rock ");
	}
}

public class SimpleConstructor {
	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) 
			new Rock();
	}
}  /* Output:
Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock 
*///:~
```

现在，在创建对象时：
```java
new Rock();
```

将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。

请注意，由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的编码风格并不适用于构造器。

不接受任何菜蔬的构造器叫做**默认构造器**，Java文档中通常使用术语**无参构造器**，但是默认构造器在Java出现之前已经使用很多年类，所以我仍旧倾向于使用它。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。对上述例子稍加修改，即可是构造器接受一个参数：

```java
//: initialization/SimpleConstructor2.java
// Constructors can hava arguments.

class Rock2 {
	Rock2(int i ) {
		System.out.print("Rock " + i + "  ");
	}
}

public class SimpleConstructor2 {
	public static void main(String[] args) {
		for (int i = 0; i < 8; i++)
			new Rock2(i);
	}
} /* Output:
Rock 0  Rock 1  Rock 2  Rock 3  Rock 4  Rock 5  Rock 6  Rock 7  
*///:~
```

有两个构造器形式参数，就可以在初始化对象时提供实际参数。例如，假设类**Tree**有一个构造器，它接受一个整型变量来表示树的高度，就可以这样创建一个**Tree**对象。

```java
Tree t = new Tree(12); // 12-foot tree
```

如果**Tree(int)**是**Tree**类唯一的构造器，那么编译器将不会允许你以其他任何方式创建**Tree**对象。

构造器有助于减少错误，并使代码更易于阅读。从概念上将，“初始化”与“创建”是批次独立的，然后在上面的代码中，你却找不到对`initialize()`方法的明确调用。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。

构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void）冥想不同。对于空返回值，尽管方法本身不会自动返回上面，但仍可选择让它返回别的东西。构造器则不会返回任何东西，你别无选择（new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值）。假如构造器具有返回值，并且允许人们自行选择返回类型，那么势必得让编译器知道该如果处理此返回值。

## 5.2 方法重载
任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取了名字。通过使用名字，你可以引用所有的对象和方法。名字起得好可以使系统更易于理解和修改。就好比写散文————目的是让读者易于理解。

将人类语言中存在细微差别的概念“映射”到程序设计中时，问题随之而生。在日常生活中，相同的词可以表达多种不同的含义————它们被“重载”了。特别是含义之间的差别很小时，这种方式十分有用。你可以说“清洗衬衫”、“清洗车”、“清洗狗”。但如果硬要这样说就显得很愚蠢：“以洗衬衫的方式洗衬衫”、“以洗车的方式洗车”、“以洗狗的方式洗狗”。这是因为听众根本不需要对所执行的动作做出明确区分。大多数人类语言具有很强的“冗余”性，所以即使漏掉了几个词，仍然可以推断出含义。不需要对每个概念都使用不同的词汇————从具体的语境中就可以推断出含义。

大多数程序设计语言（尤其是C）要求为每个方法（在这些语言中经常称为函数）都提供一个独一无二的标识符。所以绝不能用名为`print()`的函数显示了整数之后，有用一个名为`print()`的函数显示浮点数————每个函数都要有唯一的名称。

在Java（和C++）里，构造器是强制重载方法名的另外一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造名。那么要想用更多中方式创建一个对象该怎么办呢？假设你要创建一个类，既可以用标准方法进行初始化，也可以从文件中读取信息来初始化。这就需要两个构造器：一个**默认**构造器，另一个取字符串作为形式参数————该字符串表示初始化对象所需的文件名称。由于都是构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到**方法重载**。同时、尽管方法重载是构造器所必须的，但它亦可应用与其他方法，且用法同样方便。

下面这个例子同时示范了重载的构造器和重载的方法：

```java
//: initialization/Overloading.java
// Demonstration of both constructor
// and ordinary method overloading.

class Tree {
	int height;

	Tree() {
		System.out.println("Planting a seedling");
		height = 0;
	}

	Tree(int initialHeight) {
		height = initialHeight;
		System.out.println("Creating new Tree that is " + height + " feet tall");
	}

	void info() {
		System.out.println("Tree is " + height + " feet tall");
	}

	void info(String s) {
		System.out.println(s + ": Tree is " + height + " feet tall");
	}
}

public class Overloading {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			Tree t = new Tree(i);
			t.info();
			t.info("overloaded method");
		}
		new Tree();
	}
} /* Output:
Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method: Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method: Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method: Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method: Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method: Tree is 4 feet tall
Planting a seedling
*///:~
```

创建**Tree**对象的时候，既可以不含参数，也可以用树的高度当参数。前者表示一棵树苗，后者被考试已有一定高度的树木。要支持这种创建方式，得有一个默认构造器和一个采用现有高度作为参数的构造器。

或许你还像通过多种方式调用`info()`方法。例如，你像显示额外信息，可以用`info(String)`方法；没有的化就用`info()`。要是对明显相同的概念使用了不同的名字，那一定会让人很纳闷。好在有了方法重载，可以为两者使用相同的名字。

### 5.2.1 区分重载方法
要是几个方法有相同的名字，Java如何才能知道你指的是哪一个呢？其实规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表。

稍加思考，就会觉得这是合理的。毕竟，对于名字相同的方法，处理参数类型的差异意外，还有什么办法能把它们区别开呢？

甚至参数顺序的不同也足以区分两个方法。不过，一般情况下别这么做，因为这会使代码难以维护：

```java
//: initialization/OverloadingOrder.java
// Overloading based on the order of the arguments.
public class OverloadingOrder {
	static void f(String s, int i) {
		System.out.println("String: " + s + ", int: " + i);
	}

	static void f(int i, String s) {
		System.out.println("int: " + i + ", String: " + s);
	}

	public static void main(String[] args) {
		f("String first", 11);
		f(99, "Int first");
	}
} /* Output:
String: String first, int: 11
int: 99, String: Int first
*///:~
```

上例中两个方法虽然申明了相同的参数，但顺序不同，因此得以区分。

### 涉及基本类型的重载
