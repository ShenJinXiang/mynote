# 第5章 初始化与清理

> 随着计算机革命的发展，“不安全”的编程方式已逐渐成为编程代价高昂的主因之一。

*初始化与清理（cleanup）*正是涉及安全的两个问题。许多C程序的错误都源于程序员忘记初始化变量。特别是在使用程序库时，如果用户不知道如何初始化构建（或者是用户必须进行初始化的其他东西），更深如此。清理也是一个特殊问题，当使用完一个元素时，它对你也就不会有什么影响了，所以很容易把它忘记。这样一来，这个元素占用的资源就会一只得不到释放，结果是资源（尤其是内存）用尽。

C++引入了*构造器（constructor）*的概念，这是一个在创建对象时被自动调用的特殊方法。Java中也采用了构造器，并额外提供了“垃圾回收器”。对于不再使用的内存资源，垃圾回收器能自动将其释放。本章将讨论初始化和清理的相关问题，以及Java对它们提供的支持。

## 5.1 用构造器确保初始化
可以遐想为编写的每一个类都要定义一个`initialize()`方法。该方法的名称提醒你在使用其对象之前，应首先调用`initialize()`。然后，这同时意味着用户必须记得自己去调用词方法。在Java中通过提供构造器，类的设计者可确保每个对象 都会得到初始化。创建对象时，如果其类具有构造器，Java会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。

接下来的问题是如何命名这个方法。有两个问题：第一，所取的任何名字都可能与类的某个成员名称相冲突；第二，调用构造器是编译器的责任，所以必须让编译器知道应该调用哪个方法。C++语言中采用的裁决方法看来最简单且更符合逻辑，所在Java中也采用了这种方案：即构造器采用与类相同的名称。考虑到在初始化期间要自动调用构造器，这种做法就顺理成章了。

以下就是一个带有构造器的简单类：

```java
//: initialization/SimpleConstructor.java
// Demostration of a simple constructor.

class Rock {
	Rock() {
		System.out.print("Rock ");
	}
}

public class SimpleConstructor {
	public static void main(String[] args) {
		for (int i = 0; i < 10; i++) 
			new Rock();
	}
}  /* Output:
Rock Rock Rock Rock Rock Rock Rock Rock Rock Rock 
*///:~
```

现在，在创建对象时：
```java
new Rock();
```

将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能操作对象之前，它已经被恰当地初始化了。

请注意，由于构造器的名称必须与类名完全相同，所以“每个方法首字母小写”的编码风格并不适用于构造器。

不接受任何菜蔬的构造器叫做**默认构造器**，Java文档中通常使用术语**无参构造器**，但是默认构造器在Java出现之前已经使用很多年类，所以我仍旧倾向于使用它。但是和其他方法一样，构造器也能带有形式参数，以便指定如何创建对象。对上述例子稍加修改，即可是构造器接受一个参数：

```java
//: initialization/SimpleConstructor2.java
// Constructors can hava arguments.

class Rock2 {
	Rock2(int i ) {
		System.out.print("Rock " + i + "  ");
	}
}

public class SimpleConstructor2 {
	public static void main(String[] args) {
		for (int i = 0; i < 8; i++)
			new Rock2(i);
	}
} /* Output:
Rock 0  Rock 1  Rock 2  Rock 3  Rock 4  Rock 5  Rock 6  Rock 7  
*///:~
```

有两个构造器形式参数，就可以在初始化对象时提供实际参数。例如，假设类**Tree**有一个构造器，它接受一个整型变量来表示树的高度，就可以这样创建一个**Tree**对象。

```java
Tree t = new Tree(12); // 12-foot tree
```

如果**Tree(int)**是**Tree**类唯一的构造器，那么编译器将不会允许你以其他任何方式创建**Tree**对象。

构造器有助于减少错误，并使代码更易于阅读。从概念上将，“初始化”与“创建”是批次独立的，然后在上面的代码中，你却找不到对`initialize()`方法的明确调用。在Java中，“初始化”和“创建”捆绑在一起，两者不能分离。

构造器是一种特殊类型的方法，因为它没有返回值。这与返回值为空（void）冥想不同。对于空返回值，尽管方法本身不会自动返回上面，但仍可选择让它返回别的东西。构造器则不会返回任何东西，你别无选择（new 表达式确实返回了对新建对象的引用，但构造器本身并没有任何返回值）。假如构造器具有返回值，并且允许人们自行选择返回类型，那么势必得让编译器知道该如果处理此返回值。

## 5.2 方法重载
任何程序设计语言都具备的一项重要特性就是对名字的运用。当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。所谓方法则是给某个动作取了名字。通过使用名字，你可以引用所有的对象和方法。名字起得好可以使系统更易于理解和修改。就好比写散文————目的是让读者易于理解。

将人类语言中存在细微差别的概念“映射”到程序设计中时，问题随之而生。在日常生活中，相同的词可以表达多种不同的含义————它们被“重载”了。特别是含义之间的差别很小时，这种方式十分有用。你可以说“清洗衬衫”、“清洗车”、“清洗狗”。但如果硬要这样说就显得很愚蠢：“以洗衬衫的方式洗衬衫”、“以洗车的方式洗车”、“以洗狗的方式洗狗”。这是因为听众根本不需要对所执行的动作做出明确区分。大多数人类语言具有很强的“冗余”性，所以即使漏掉了几个词，仍然可以推断出含义。不需要对每个概念都使用不同的词汇————从具体的语境中就可以推断出含义。

大多数程序设计语言（尤其是C）要求为每个方法（在这些语言中经常称为函数）都提供一个独一无二的标识符。所以绝不能用名为`print()`的函数显示了整数之后，有用一个名为`print()`的函数显示浮点数————每个函数都要有唯一的名称。

在Java（和C++）里，构造器是强制重载方法名的另外一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造名。那么要想用更多中方式创建一个对象该怎么办呢？假设你要创建一个类，既可以用标准方法进行初始化，也可以从文件中读取信息来初始化。这就需要两个构造器：一个**默认**构造器，另一个取字符串作为形式参数————该字符串表示初始化对象所需的文件名称。由于都是构造器，所以它们必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器同时存在，必须用到**方法重载**。同时、尽管方法重载是构造器所必须的，但它亦可应用与其他方法，且用法同样方便。

下面这个例子同时示范了重载的构造器和重载的方法：

```java
//: initialization/Overloading.java
// Demonstration of both constructor
// and ordinary method overloading.

class Tree {
	int height;

	Tree() {
		System.out.println("Planting a seedling");
		height = 0;
	}

	Tree(int initialHeight) {
		height = initialHeight;
		System.out.println("Creating new Tree that is " + height + " feet tall");
	}

	void info() {
		System.out.println("Tree is " + height + " feet tall");
	}

	void info(String s) {
		System.out.println(s + ": Tree is " + height + " feet tall");
	}
}

public class Overloading {
	public static void main(String[] args) {
		for (int i = 0; i < 5; i++) {
			Tree t = new Tree(i);
			t.info();
			t.info("overloaded method");
		}
		new Tree();
	}
} /* Output:
Creating new Tree that is 0 feet tall
Tree is 0 feet tall
overloaded method: Tree is 0 feet tall
Creating new Tree that is 1 feet tall
Tree is 1 feet tall
overloaded method: Tree is 1 feet tall
Creating new Tree that is 2 feet tall
Tree is 2 feet tall
overloaded method: Tree is 2 feet tall
Creating new Tree that is 3 feet tall
Tree is 3 feet tall
overloaded method: Tree is 3 feet tall
Creating new Tree that is 4 feet tall
Tree is 4 feet tall
overloaded method: Tree is 4 feet tall
Planting a seedling
*///:~
```

创建**Tree**对象的时候，既可以不含参数，也可以用树的高度当参数。前者表示一棵树苗，后者被考试已有一定高度的树木。要支持这种创建方式，得有一个默认构造器和一个采用现有高度作为参数的构造器。

或许你还像通过多种方式调用`info()`方法。例如，你像显示额外信息，可以用`info(String)`方法；没有的化就用`info()`。要是对明显相同的概念使用了不同的名字，那一定会让人很纳闷。好在有了方法重载，可以为两者使用相同的名字。

### 5.2.1 区分重载方法
要是几个方法有相同的名字，Java如何才能知道你指的是哪一个呢？其实规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表。

稍加思考，就会觉得这是合理的。毕竟，对于名字相同的方法，处理参数类型的差异意外，还有什么办法能把它们区别开呢？

甚至参数顺序的不同也足以区分两个方法。不过，一般情况下别这么做，因为这会使代码难以维护：

```java
//: initialization/OverloadingOrder.java
// Overloading based on the order of the arguments.
public class OverloadingOrder {
	static void f(String s, int i) {
		System.out.println("String: " + s + ", int: " + i);
	}

	static void f(int i, String s) {
		System.out.println("int: " + i + ", String: " + s);
	}

	public static void main(String[] args) {
		f("String first", 11);
		f(99, "Int first");
	}
} /* Output:
String: String first, int: 11
int: 99, String: Int first
*///:~
```

上例中两个方法虽然申明了相同的参数，但顺序不同，因此得以区分。

### 5.2.2 涉及基本类型的重载
基本类型能从一个“较小”的类型自动提升至一个“较大”的类型，此过程一旦牵涉到重载，可能会造成一些混淆。以下例子说明了将基本类型传递给重载方法时发生的情况：

```java
public class PrimitiveOverloading {
	void f1(char x) { printnb("f1(char) "); }
	void f1(byte x) { printnb("f1(byte) "); }
	void f1(short x) { printnb("f1(short) "); }
	void f1(int x) { printnb("f1(int) "); }
	void f1(long x) { printnb("f1(long) "); }
	void f1(float x) { printnb("f1(float) "); }
	void f1(double x) { printnb("f1(double) "); }

	void f2(byte x) { printnb("f2(byte) "); }
	void f2(short x) { printnb("f2(short) "); }
	void f2(int x) { printnb("f2(int) "); }
	void f2(long x) { printnb("f2(long) "); }
	void f2(float x) { printnb("f2(float) "); }
	void f2(double x) { printnb("f2(double) "); }

	void f3(short x) { printnb("f3(short) "); }
	void f3(int x) { printnb("f3(int) "); }
	void f3(long x) { printnb("f3(long) "); }
	void f3(float x) { printnb("f3(float) "); }
	void f3(double x) { printnb("f3(double) "); }

	void f4(int x) { printnb("f4(int) "); }
	void f4(long x) { printnb("f4(long) "); }
	void f4(float x) { printnb("f4(float) "); }
	void f4(double x) { printnb("f4(double) "); }

	void f5(long x) { printnb("f5(long) "); }
	void f5(float x) { printnb("f5(float) "); }
	void f5(double x) { printnb("f5(double) "); }

	void f6(float x) { printnb("f6(float) "); }
	void f6(double x) { printnb("f6(double) "); }

	void f7(double x) { printnb("f7(double) "); }

	void testConstVal() {
		printnb("5: ");
		f1(5); f2(5); f3(5); f4(5); f5(5); f6(5); f7(5);
		System.out.println();
	}

	void testChar() {
		char x = 'x';
		printnb("char: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testByte() {
		byte x = 0;
		printnb("byte: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testShort() {
		short x = 0;
		printnb("short: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testInt() {
		int x = 0;
		printnb("int: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testLong() {
		long x = 0;
		printnb("long: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testFloat() {
		float x = 0;
		printnb("float: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void testDouble() {
		double x = 0;
		printnb("double: ");
		f1(x); f2(x); f3(x); f4(x); f5(x); f6(x); f7(x);
		System.out.println();
	}

	void printnb(Object obj) {
		System.out.print(obj + " ");
	}

	public static void main(String[] args){
		PrimitiveOverloading p = new PrimitiveOverloading();
		p.testConstVal();
		p.testChar();
		p.testByte();
		p.testShort();
		p.testInt();
		p.testLong();
		p.testFloat();
		p.testDouble();
	}
} /* Output
5:  f1(int)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
char:  f1(char)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
byte:  f1(byte)  f2(byte)  f3(short)  f4(int)  f5(long)  f6(float)  f7(double)  
short:  f1(short)  f2(short)  f3(short)  f4(int)  f5(long)  f6(float)  f7(double)  
int:  f1(int)  f2(int)  f3(int)  f4(int)  f5(long)  f6(float)  f7(double)  
long:  f1(long)  f2(long)  f3(long)  f4(long)  f5(long)  f6(float)  f7(double)  
float:  f1(float)  f2(float)  f3(float)  f4(float)  f5(float)  f6(float)  f7(double)  
double:  f1(double)  f2(double)  f3(double)  f4(double)  f5(double)  f6(double)  f7(double)  
*///:~
```

你会发现常数值5被当作**int**值处理，所以如果有某个重载方法接受int型参数，它就会被调用。至于其他情况，如果传入的数据类型（实际参数类型）小于方法中申明的形式参数类型，实际数据类型就会被提升，char型略有不同，如果无法找到恰好接受char参数的方法，就会把char直接提升至int型。

如果传入的实际参数大于重载方法声明的形式参数，就得通过类型转换来执行窄化转换。如果不这样做，编译器就会报错。

### 5.2.3 以返回值区分重载方法
读者可能会想：“在区分重载方法的时候，为什么只能以类名和方法的形参列表作为标准呢？能否考虑用方法的返回值来区分呢？”比如下面两个方法，虽然有同样的名字和形式参数，但却很容易区分它们：

```java
void f() {}
inf f() { return 1; }
```

只要编译器可以根据语境明确判断出语义，比如在`int x = f()`中，那么的确可以据此区分重载方法。不过，有时你并不关心方法的返回值，你想要的是方法调用的其他效果（这常被成为“为了副作用而调用”），这时你可能会调用方法而忽略其返回值。所以，如果像下面只要调用方法；

```java
f();
```

此时Java如何才能判断该调用哪一个`f()`呢？别人该如何理解这种代码呢？ 因此，根据方法的返回值来区分重载方法是行不通的。

## 5.3 默认构造器
如前所述，默认构造器（又名“无参”构造器）是没有形式参数的————它的作用是创建一个“默认对象”。如果你写的类中没有构造器，则编译器会自动帮你创建一个默认构造器。例如：

```java
//: initialization/DefaultConstructor.java

class Bird {}

public class DefaultConstructor {
	public static void main(String[] args) {
		Bird b = new Bird(); // Default!
	}
} ///:~
```

表达式

```java
new Bird()
```

行创建了一个新对象，并调用其默认构造器————即使你没有明确定义它。没有它的话，就没有方法可调用，就无法创建对象。但是，如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器：

```java
// initialization/NoSynthesis.java

class Bird2 {
	Bird2(int i) {}
	Bird2(double d) {}
}

public class NoSynthesis {
 public static void main(String[] args) {
	//! Bird2 b = new Bird2(); // no default
	Bird2 b2 = new Bird2(1);
	Bird2 b3 = new Bird2(1.0);
 }
} ///:~
```

要是你这样写：

```java
new Bird2()
```

编译器就会报错：没有找到匹配的构造器。这就好比，要是你没有提供任何构造器，编译器会认为“你需要一个构造器，让我给你制造一个把”；但假如你已写了一个构造器，编译器则会认为“啊，你已写了一个构造器，所以你知道你在做什么；你是刻意忽略了默认构造器”。

## 5.4 this关键字
如果有同一类型的两个对象，分别是`a`和`b`。你可能像知道，如何才能让这两个对象都能调用`peel()`方法呢？

```java
//: initialization/BananaPeel.java
class Banana { void peel(int i) { /* ... */ } }

public class BananaPeel {
	public static void main(String[] args) {
		Banana a = new Banana(),
			   b = new Banana();
		a.peel(1);
		b.peel(2);
	}
} ///:~
```

如果只有一个**peel()**方法，它如何知道是被a还是被b所调用呢？

为了能用简便、面向对象的语法来编写代码————即“发送消息给对象”，编译器做了一些幕后工作。它暗自把“所操作对象的引用”作为第一个参数传递给**peel()**。所以上述两个方法调用就变成了这样：

```java
Banana.peel(a, 1);
Banana.peel(b, 2);
```

这是内部的表示形式。我们并不能这样书写代码，并试图通过编译；但这种写法的却能帮你了解实际所发生的事情。

假设你希望在方法的内部获得对当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以没有标识符可用。但是，为此有个专门的关键字：**this**。**this**关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。**this**的用法和其他对象引用并无不同。但要注意，如果在方法内部调用同一个类的另一个方法，就不必使用this，直接调用即可。当前方法中的**this**引用会自动应用于同一类中的其他方法。所以可以这样写代码：

```java
//: initialization/Apricot.java
public class Apricot {
	void pick() { /* ...*/ }
	void pit { pick(); /* ... */ }
} ///:~
```

在**pit()**内部，你可以写**this.pick()**,但无此必要。编译器能帮你自动添加。只有当需要明确指出当前对象的引用时，菜需要使用**this**关键字。例如，当需要返回当前对象的引用时，就常常在return语句里这样写：

```java
//: initialization/Leaf.java
// Simple use of the "this" keyword.

public class Leaf {
	int i = 0;
	Leaf increment() {
		i++;
		return this;
	}

	void print() {
		System.out.println("i = " + i);
	}

	public static void main (String[] args) {
		Leaf x = new Leaf();
		x.increment().increment().increment().print();
	}
} /* Output:
i = 3
*////:~
```

由于**increment()**通过**this**关键字返回了对当前对象的引用，所以很容易在一条语句里对同一个对象执行多次操作。

this关键字对于将当前对象传递给其他方法也很有用：

```java
//: initialization/PassingThis.java

class Person {
	public void eat(Apple apple) {
		Apple peeled = apple.getPeeled();
		System.out.println(""Yummy"");
	}
}

class Peeler {
	static Apple peel(Apple apple) {
		return apple;
	}
}

class Apple {
	Apple getPeeled { return Peeler.peel(this); }
}

public class PassingThis {
	public static void main(String[] args) {
		new Person().eat(New Apple());
	}
} /* Output:
Yummy
*///:~
```

Apple需要调用Peeler.peel()方法，它是一个外部的工具方法，将执行由于某些原因而必须放在Apple外部的操作（也许是因为该外部方法要应用于许多不同的类，而你却不想重复这些代码）。为了将其自身传递给外部方法，Apple必须使用this关键字。

### 5.4.1 在构造器中调用构造器

可能为一个类写了多个构造器，有时可能想在一个构造器中调用另一个构造器，以避免重复代码。可用**this**关键字做到这一点。

通常写**this**的时候，都是指“这个对象”或者“当前对象”，而且它本身表示当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有了不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；这样，调用其他构造器就有了直接的途径：

```java
//: initialization/Flower.java
// Calling constructors with "this"
import static net.mindview.util.Print.*;

public class Flower {
	int petalCount = 0;
	String s = "initial value";

	Flower(int petals) {
		petalCount = petals;
		print("Constructor w/ int arg only. petalCount= " + petalCount);
	}

	Flower(String ss) {
		print("Constructor w/ String arg only. s = " + ss);
		s = ss;
	}

	Flower(String s, int petals) {
		this(petals);
		//! this(s); // Can't call two!
		tihs.s = s ;
		print("String & int args");
	}

	Flower() {
		this("hi", 47);
		print("default constructor (no args)");
	}

	void printPetalCount() {
		//! this(11); // Not inside non-constructor!
		print("petalCount = " + petalCount + " s + " + s);
	}

	public static void main(String[] args) {
		Flower x = new Flower();
		x.printPetalCount();
	}
} /* Output
Constructor 2/ int arg only. petalCount = 47
String & int args
default constructor (no args)
petalCount = 47 s = hi
*///:~
```

构造器**Flower(String s, int petals)**表明：尽管可以用**this**调用一个构造器，但却不能调用两个。此外，必须将构造器调用至于最起始处，否则编译器会报错。

这个例子也展示了**this**的另一种用法。由于参数**s**的名称和数据成员**s**的名字相同，所以会产生歧义。使用**this.s**来代表数据成员就解决这个问题。在Java程序代码中经常出现这种写法，本书中也常这么写。

**printPetalCount()**方法表明，除构造器之外，编译器禁止在其他任何方法中调用构造器。

### 5.4.2 static的含义
了解**this**关键字之后，就能更全面的理解static（静态）方法的含义，static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来倒是可以的。而且可以在没有创建任何对象的前提下，仅仅通过类本省来调用static方法。这实际上正是static方法的主要用途。它很像全局方法。Java中禁止使用全局方法，但你在类中置入static方法就可以访问其他static方法和static域。

有些人认为static方法不是“面向对象”的，因为它们的确具有全局函数的语义；使用static方法时，由于不存在this，所以不是通过“向对象发送消息”的方式来完成的。的却，要是在代码中出现大量的static方法，就该重新考虑自己的设计了。然后，static的概念有其实用之处，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。事实上，Smalltalk语义里的“类方法”就是域static方法相对应的。

## 5.5 清理：终结处理和垃圾回收
程序员都了解初始化的重要性，但常常会忘记同样也重要的清理工作。毕竟，谁需要清理一个int呢？但在使用程序库时，把一个对象用完后就“弃之不顾”的做法并非总谁安全的。当然，Java有垃圾回收器负责回收无用对象占据的内存资源。但也有特殊情况：假定你的对象（并非使用new）获得一块“特殊”的内存区域，由于垃圾回收器只知道释放那些经由new分配的内存，所以它不知道该如何释放该对象的这块“特殊”内存。为了应对这种情况，Java允许在类中定义一个名为**Finalize()**的方法。它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用器**finalize()**方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。所以要是你打算用**finalize()**，就能在垃圾回收时刻做一些重要的清理工作。

这里有一个潜在的编程陷阱，因为有些程序员（特别是C++程序员）刚开始可能会误把**finalize()**当作C++中的**析构函数**（C++中销毁对象必须用到这个函数）。所以有必要明确区分以下：在C++中，对象一定会被销毁（如果程序中没有缺陷的话）；而Java里的对象却并非总是被垃圾回收。或者换句话说：

> 对象可能不被垃圾回收。
> 垃圾回收并不定语“析构”。

牢记这些，就能原理困扰。这意味着在你不再需要某个对象之前，如果必须执行某些动作，那么你得自己去做。Java并未提供“析构函数”或相似的概念，要做类似的清理工作，必须自己动手创建一个执行清理工作的普通方法。例如，假设某个对象在创建过程中会将自己绘制到屏幕上，如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在finalize()里假如某种擦除功能，当“垃圾回收”发生时（不能保证一定会发生），finalize()得到了调用，图像就会被擦除。要是“垃圾回收”没有发生，图像就会一直保留下来。

也许你会发现，只要程序没有频临存储空间用完的那一刻，对象占用的空间站就总也得不到释放。如果程序执行结束，并且垃圾回收器一直没有释放你创建的任何对象的存储空间，则随着程序的退出，那些资源也会全部交还给操作系统。这个策略是恰当的，因为垃圾回收本身也有开销，要是不使用它，那就不用知乎这部分开销了。

### 5.5.1 finalize()的用途何在
此时，读者已经明白了不该将**finalize()**作为通用的清理方法。那么，**finalize()**的真正用途是什么呢？

这引出了要记住的第三点：

> 垃圾回收只与内存有关。

也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。

但这是否意味着要是对象中含有其他对象，finalize()就应明确释放那些对象呢？不，无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过，读者也看到了，Java中一切皆为对象，那么这种特殊情况是怎么会是呢？

看来之所以要有finalize()，是由于在分配内存是可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式（关于本地方法的讨论见本书电子版第二版，在www.MindView.net网站上有收录）。本地方法目前只支持C和C++，但他们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的**malloc()**函数系列来分配存储空间，而且除非调用了**free()**函数，否则存储空间将得不到释放，从而造成内存泄漏。当然，**free()**是C和C++中的函数，所以需要在**finalize()**中用本地方法调用它。

至此，读者或许已经明白了不要过多地使用finalize()的道理了。对，它确实不是进行普通的清理工作的合适场所。那么，普通的清理工作应该在哪里执行呢？

### 5.5.2 你必须实施清理
要清理一个对象，用户必须在需要清理的时刻调用执行清理动作的方法。这听起来似乎很简单，但却与C++中的“析构函数”的概念稍有抵触。在C++中，所有对象都会被销毁，或者说，应该被销毁。如果在C++中创建了一个局部对象（也就是在堆栈上创建，这在Java中行不通），此时的销毁动作发生在以“右花括号”为边界的、此对象作用域的末尾处。如果对象是用`new`创建的（类似与Java中），那么当程序员调用C++的`delete`操作符时(Java没有这个命令)，就会调用相应的析构函数。如果程序员忘记调用`delete`，那么永远不会调用析构函数，这样就会出现内存泄漏，对象的其他部分也不会得到清理。这种缺陷很难跟踪，这也是让C++程序员转向Java的一个主要因素。

相反，Java不允许创建局部对象，必须使用`new`创建对象。在Java中也没有用于释放对象的`delete`，因为垃圾回收器会帮助你释放存储空间。甚至可以肤浅地认为，正是由于垃圾收集机制的存在，使得Java没有析构函数。然后，随着学习的深入，读者就会明白垃圾回收器的存在并不能完全代替析构函数。（而且绝对不能直接调用finalize()，所以这也不是一种解决方法。）如果希望进行释放存储空间之外的清理工作，还是得明确调用某个恰当的Java方法。这就等于使用析构函数了，只是没有它方便。

记住，无论是“垃圾回收”还是“终结”，都不保证一定会发生。如果Java虚拟机（JVM）并未面临内存耗尽的情形，它是不会浪费时间去执行垃圾回收以恢复内存的。

### 5.5.3 终结条件
通常，不能指望finalize()，必须创建其他的“清理”方法，并且明确地调用它们。看来，finalize()只能存在与程序员很难用到的一些晦涩用法里了。不过finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象**终结条件**的验证。

当对某个对象不再感兴趣————也就是它可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全地释放。例如，要是对象代表了一个打开的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。finalize()可以用来最终发现这种情况————尽管它并不总是会被调用。如果某次finalize()的动作使得缺陷被发现，那么就可据此找出问题所在————这才是人们真正关心的。

以下是个简单的例子，示范了finalize()可能的使用方式：

```java
//: initialization/TerminationCondition.java
// Using finalize() to detect an object that
// hasn't been properly cleaned up.

class Book {
	boolean checkedOut = false;
	Book(boolean checkOut) {
		checkedOut = checkOut;
	}

	void checkIn() {
		checkedOut = false;
	}

	protected void finalize() {
		if(checkedOut) {
			System.out.println("Error: checked out");
			// Normally. you'll also do this:
			// super.finalize(); // Call the base-class version
		}
	}
}

public class TerminationCondition {
	public static void main(String[] args) {
		Book novel = new Book(true);
		// Proper cleanup;
		novel.checkIn();
		// Drop the reference. forget to clean up:
		new Book(true);
		// Force garbage collection & finalization:
		System.gc();
	}
} /* Output:
Error: checked out
*///:~
```

本例的终结条件是：所有**Book**对象在被当作垃圾回收之前都硬被签入（check in）。但在**main()**方法中，由于程序员的错误，有一本书未被签入。要是没有**finalize()**来验证终结条件，将很难发现这个缺陷。

注意，**System.gc()**用于强制进行终结动作。即使不真美做，通过重复地执行程序（假设程序将分配大量的存储空间而导致垃圾回收动作的执行），最终也能找出错误的Book对象。

你应该总是假设基类版本的finalize()也要做某些重要的事情，因此要使用super来调用它，就像在`Book.finalize()`中看到的那样。在本例中，它被注释掉了，因为它需要进行异常处理，而我们还没有介绍过这部分内容。

### 5.5.4 垃圾回收器如何工作
在以前所用过的程序语言中，在堆上分配对象的代价十分高昂，韵词读者自然觉得Java中所有对象（基本类型除外）都在堆上分配的方式也非常高昂。然而，垃圾回收器对于提高对象的创建速度，却具有明显的效果。听起来很奇怪————存储空间的释放竟会影响存储空间的分配，但这确实是某些Java虚拟机的工作方式。这也意味着，Java从堆分配空间的速度，可以和其他语言从堆栈上分配空间的速度相媲美。

打个比方，你可以把C++里的堆想像成一个大院子，里面每个对象都负责管理自己的地盘。一段时间后，对象可能被销毁，但地盘必须加以重用。在某在Java虚拟机中，堆的实现截然不同：它更像一个传送带，没分配一个新对象，它就往前移动一格。这意味着对象存储空间的分配速度非常快。Java的“堆指针”值是简单滴移动尚未分配的区域，器效率比得上C++在堆栈上分配空间的效率。当然，实际过程中在薄记工作方面还有少量额外开销，但闭上查找可用空间开销大。

读者也许已经意识到了，Java中的堆未必完全像传送带那样工作。要真是那样的话，势必会导致频繁的内存页面调度————将其移进移出硬盘，因此会先的需要用有比实际需要更多的内存。页面调度会显著地影响性能，最终，在创建了足够多的对象之后，内存资源将耗尽。其中的秘密在于垃圾回收器的介入。当他工作时，将一面回收空间，一面使对中的对象紧凑排列，这也“堆指针”就可以很容易移动到更靠近传送带的开始处，也就尽量避免了页面错误。通过垃圾回收器对对象重新排列，实现了一种高速的，有无限空间可供分配的堆模型。

要想更好地理解Java中的垃圾回收，先了解其他系统中的垃圾回收机制将会很有帮助。引用记数是一种简单但速度很慢的垃圾回收技术。每个对象都含有一个引用计数器，当有引用连接至对象时，引用计数加1.当引用离开作用域被置为null时，引用记数减1.虽然管理引用记数的开销不大，但这项开销在整个程序生命周期中将持续发生。垃圾回收器会在含有全部对象的列表上遍历，当发现某个对象的引用计数为0时，就释放其占用的空间（但是，引用记数模式经常会在记数值变为0时立即释放对象）。这种方法有个缺陷，如果对象之间存在循环引用，可能会出现“对象应该被回收，但引用计数却不为零”的情况。堆垃圾回收器而言，定位这也的交互自引用的对象组所需的工作量极大。引用记数常用来说明垃圾回收机的工作方式，但似乎从未被应用于任何一种Java虚拟机的实现中。

在一些更快的模式中，垃圾回收器并非基于引用记数技术。它们一句的思想是：对任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中的引用。这个引用链条可能会穿过数个对象层次。由此，如果从堆栈和静态存储区开始，遍历所有的引用，就能找到所有“活”的对象。对于发现的每个引用，必须追逐它所引用的对象，然后是此对象包含的所有引用，如此反复进行，知道“根源于堆栈和静态存储区的引用”，所形成的网络全部被访问为止。你所访问过的对象必须都是“活”的。注意，这就解决了“交互自引用的对象组”的问题————这种现象根本不会被发现，因此也就被自动回收了。

在这种方式下，Java虚拟机将采用一种自适应的垃圾回收技术。至于如何处理找到的存活对象，取决于不同的Java虚拟机实现。有一种做法名为停止-复制（stop-and-copy）。显然这意味着，先暂停程序的运行（所以它不属于后台回收模式），然后将所有存活的对象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，它们是一个挨着一个的，所以新堆保持紧凑排列，然后就可以按前述的方法简单、直接的分配新空间了。

当把对象从一处搬到另一处时，所有指向它的那些引用都必须修正。位于堆或静态存储区的引用可以直接被修正，但可能还有其他指向这些对象的引用，它们在遍历的过程中才能被找到（可以想像成有个表格，将旧地址映射到新地址）。

对于这种所谓的“复制式回收器”而言，效率会降低，这有两个原因。首先，得有两个堆，然后得在这两个堆之间来回捣腾，从而维护比实际需要多一倍的空间。某些Java虚拟机对此问题的处理方式是，按需从堆中分配几块较大的内存，复制动作发生在这些大块内存之间。

第二个问题在于复制。程序进入稳定状态之后，可能智慧产生少量垃圾，甚至没有垃圾。尽管如此，复制式回收器仍然会将所有内存自一处复制到另一处，这很浪费。为了避免这种情形，一些Java虚拟机会进行检查：要是没有新垃圾产生，就会转移到另一个工作模式（即“自适应”）。这种模式成为标记-清扫（mark-and-sweep），Sun公司早期版本的Java虚拟机使用了这种技术。对一般用途而言，“标记-清扫”方式速度相当慢，但是当你知道只会产生少量垃圾甚至不会产生垃圾时，它的速度就很快了。

“标记-清扫”所以剧的思路同样是从堆栈和静态存储区触发，遍历所有的引用，进而找出所有存活的对象。每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何对象。只有全部标记工作完成的时候，清理动作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下的堆空间是不连续的，垃圾回收器要是希望得到连续空间的话，就得重新整理剩下的对象。

“停止-复制”的意思是这种垃圾回收动作不是在后台进行的；相反，垃圾回收动作发生的同时，程序将会被暂停。在Sun公司的文档中会发现，许多参考文献将垃圾回收视为低优先级的后台进程，但事实上垃圾回收器在Sun公司早期版本的Java虚拟机中并非以这种方式实现的。当可用内存数量较低时，Sun版本的垃圾回收器会暂停运行程序，同样，“标记-清扫”工作也必须在程序暂停的情况下才能进行。

如前文所述，在这里所讨论的Java虚拟机中，内存分配以较大的“块”为单位。如果对象较大，它会占用单独的块。严格来说，“停止-复制”要求在释放就有对象之前，必须先把所有存活对象从旧堆复制到新堆，这将导致大量内存复制行为。有了块之后，垃圾回收器在回收的时候就可以在废弃的块里拷贝对象了。每个块都用相应的代数来比记录它是否还存活。通常，如果块在某处被引用，其代数会增加；垃圾回收器将对上述回收动作之后新分配的块进行整理。这对处理大量短命的临时对象很有帮助。垃圾回收器会定期进行完整的清理动作————大型对象仍然不会被复制（只是其代数会增加），内涵小型对象的那些快则被复制并整理。Java虚拟机会进行监视，如果所有对象都很稳定，垃圾回收器的效率降低的话，就切换到“标记-清扫”方式；同样，Java虚拟机会跟踪“标记-清扫”的效果，要是对空间出现了很多碎片，就会切换回“停止-复制”方式。这就是“自适应”技术，你可以给它个啰嗦的称呼：“自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。

Java虚拟机中有许多附加技术用以提升速度。尤其是于加载器操作有关的，被称为“即时”（Just-In-Time, JIT）编译器的技术。这种技术可以把程序全部或部分翻译成本地机器码（这本来是Java虚拟机的工作），程序运行速度因此得以提升。当需要装载某个类（通常是在为该类创建第一个对象）时，编译器会先找到其**.class**文件，然后将该类的字节码装入内存。此时，有两种方案可供选择。一整是就让即时编译器编译所有代码。但这种做法有两个缺陷：这种加载动作散落在整个程序生命周期内，累加起来要花更多时间；并且会增加可执行代码的长度（字节码要比即使编译器展开后的本地机器码小得多），这将导致页面调度，从而降低程序的速度。另一种做法成为惰性评估（lazy evaluation），意思是即使编译器只在必要的时候菜编译代码。这样，从不会被执行的代码也许就压根不会被JTIT所编译。新版JDK中的Java HotSpot技术就采用了类似的方法，代码每次被执行的时候都会做一些优化，所以执行的次数越多，它的速度就越快。

## 5.6 成员初始化
Java尽力保证：所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，Java以编译时错误的形式来贯彻这种保证。所以如果写成：

```java
void f() {
	int i;
	i++; // Error --i not initialized
}
```

就会得到一条出错信息，告诉你`i`可能尚未初始化。当然，编译器也可以为`i`赋一个默认值，但是为初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。因此强制程序员提供一个初始值，往往能够帮助找出程序里的缺陷。

要是类的数据成员（即字段）是基本类型，情况就会变得有些不同。正如在“一切都是对象”一张所看到的，类的每个基本类型数据成员保证都会有一个初始值。下面的程序可以验证这类情况，并显示它们的值：

```java
//: initialization/InitialValues.java
// Shows default initial values.

public class InitialValues {
	Boolean t;
	char c;
	byte b;
	short s;
	int i;
	long l;
	float f;
	double d;
	InitialValues reference;

	void printInitalValues () {
		print("Date type		Initial value");
		print("boolean          " + t);
		print("char             [" + c + "]" );
		print("byte             " + b);
		print("short            " + s);
		print("int              " + i);
		print("long             " + l);
		print("float            " + f);
		print("double           " + d);
		print("reference        " + reference);
	}

	void print(Object obj) {
		System.out.println(obj);
	}

	public static void main(String[] args) {
		InitialValues iv = new InitialValues();
		iv.printInitalValues();
	}
} /* Output
Date type		Initial value
boolean          null
char             []
byte             0
short            0
int              0
long             0
float            0.0
double           0.0
reference        null
*///:~
```

可见尽管数据成员的初值没有给出，但他们确实有初值（char值为0，所以显示为空白）。这样至少不会冒“未初始化变量”的风险了。

在类里定义一个对象引用时，如果不将其初始化，此引用就会获得一个特殊之null。
