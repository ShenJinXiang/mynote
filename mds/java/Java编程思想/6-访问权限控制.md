# 第6章 访问权限控制
**访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。**

所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。如果你把一个代码段放到了某个位置，等过一会回头再看时，有可能会发现有更好的方式区实现相同的功能。这正是重构的原动力之一，重构即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。

但是，在这种修改和完善代码的愿望之下，也存在这巨大的压力。通常总是有一些消费者（客户端程序员）需要你的代码在某些方面保持不变。因此你像改变代码，而他们却像让代码保持不变。由此而产生了在面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”。

这对类库（library）而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，它们并不需要改写代码。从另一个方面来说，类库的开发这必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。

这一目标可以通过约定来达到。例如，类库开发者必须同一在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端程序员的代码。但是，与之相反的情况会更加几首。在有域（即数据成员）存在的情况下，类库开发者要怎样才能知道究竟都有那些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。

为了解决这一问题，Java提供了访问权限修饰词，以供类库开发人员像客户端程序员指明哪些是可用的，那些是不可用的。访问权限控制的登记，从最大权限到最小权限以此为：**public**、**protected**，包访问权限（没有关键词）和**private**。根据前述内容，读者可能会认为，作为一名类库设计院，你会尽可能将一切方法都定为**private**，而仅向客户端程序员公开你愿意让它们使用的方法。这样做是完全正确的，尽管对于那些经常使用别的语言（特别是C语言）编写程序并在访问事物时不受任何限制的人而言，这与它们的直觉相违背。到了本章末，读者将会信服Java的访问权限控制的价值。

不过，构建类库的概念以及对于谁有权限用该类库构建的控制问题都还是不完善的。其中仍旧存在着如果将构建捆绑到一个内聚的类库单元中的问题。对于这一点，Java用关键字**package**加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。为此，要开始学习本章，首先要学习如何将类库构建置于包中，然后就会理解访问权限修饰词的全部含义。

## 6.1 包：库单元
包内包含有一组类，它们在单一的名字空间之下被组织在一起。

例如，在Java的标准库发布中国呢有一个工具库，它被组织在java.util名字空间下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。

```java
:// access/FullQualification.java

public class FullQualification {
	public static void main(String[] args) {
		java.util.ArrayList list = new java.util.ArrayList();
	}
}
```

这立刻就使程序变得很冗长了，因此你可能想转而使用**import**关键字。如果你想要导入单个的类，可以在**import**语句中命名该类：

```java
//: access/SingleImport.java
import java.util.ArrayList;

public class SingleImport {
	public static void main(String[] args) {
		ArrayList list = new java.util.ArrayList();
	}
}
```

现在，就可以不用限定地使用ArrayList了。但是，这样做**java.util**中的吉他类仍旧是都不可用的。要想导入其中所有的类，只需要使用“*”，就像在本书剩余部分的示例中所看到的那样：

```java
import java.util.*;
```

我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。A类中的方法`f()`与B类中的具有相同特征标记（参数列表）的方法`f()`不会彼此冲突。但是如果类名相互冲突又该怎么办呢？假设你编写了一个`Stack`类并安装到了一台机器上，而该及其上已经有了一个别人编写的`Stack`类，我们该如何解决呢？由于名字之间的潜在冲突，在Java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情。

到目前为止，书中大多数示例都存与单个文件中，并专为本地使用（local use)而设计，因为尚未受到包名的干扰。这些示例实际上已经位于包中了：即*未命名包*，或成为*默认包*。这当然也是一种选择，而且为了简单期间，在本书其他部分都尽可能地使用了此方法。不过如果你正在准备编写对在同一台机器上共存的其他Java程序友好的类库或程序的话，就需要考虑如何防止类名称之间的冲突问题。

当编写一个Java源代码文件时，此文件通常成称为编译单元（有时也称为转译单元）。每个编译单元都必须有一个后缀名.Java，而在编译单元内则可以有一个**public**类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个**public**类，否则编译器就不会接受。如果在该编译单元这中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是**public**类，而且它们主要用来为主**public**提供支持。

### 6.1.1 代码组织
当编译一个.java文件时，在**.java**文件中的每个类都会有一个输出文件，而该输出文件的名称与**.java**文件中的每个类的名称相同，只是多了一个后缀名**.class**。因此，在编译少量**.java**文件之后，会得到大量的**.class**文件。如果用编译型语言编写过程序，那么对于编译器产生一个中间文件（通常是一个obj文件），然后再与通过链接器（用以创建一个可执行文件）或类库产生器（librarian，用于创建一个类库）产生的其他同类文件捆绑在一起的情况，可能早已司空见惯。但这并不少Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的**.class**文件。Java解释器负责这些文件的查找、装载和解释。

类库实际上是一组类文件。其中每个文件都有一个**public**类，以及任意数量的非**public**类。因此每个文件都有一个构建。如果希望这些勾结（每一个都有它们自己独立的.java和.class文件）从属于同一个群组，就可以使用关键字**package**。

如果使用**package**语句，它必须是文件中除注释以外的第一句程序代码。在文件起始处写：

```java
package access;
```

就表示你在声明该编译单元是名为**access**的类库的一部分。或者换种说法，你正在声明该编译单元中的**public**类名称是位于**access**名称的保护伞下。任何想要使用该名称的人都必须使用前面给出的选择，指定全名或者与**access**结合使用关键字**import**。（请注意，Java包的命名规则全部使用小写字母，包括中间子也是如此。）


例如，假设文件的名称是**MyClass.java**，这就意味着该文件中有且只有一个**public**类，该类的名称必须是**MyClass**（注意大小写）：

```java
//: access/mypackage/MyClass.java
package access.mypackage;

public class MyClass{
	// ...
} ///:~
```

现在，如果有人想用**MyClass**或者是**access**中的任何其他**public**类，就必须使用关键字**import**来使**access**中的名称可用。另一种选择是给出完整的名称：
