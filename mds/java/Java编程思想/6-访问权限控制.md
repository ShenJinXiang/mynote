# 第6章 访问权限控制
**访问控制（或隐藏具体实现）与“最初的实现并不恰当”有关。**

所有优秀的作者，包括那些编写软件的程序员，都清楚其著作的某些部分直至重新创作的时候才变得完美，有时甚至要反复重写多次。如果你把一个代码段放到了某个位置，等过一会回头再看时，有可能会发现有更好的方式区实现相同的功能。这正是重构的原动力之一，重构即重写代码，以使得它更可读、更易理解，并因此而更具可维护性。

但是，在这种修改和完善代码的愿望之下，也存在这巨大的压力。通常总是有一些消费者（客户端程序员）需要你的代码在某些方面保持不变。因此你像改变代码，而他们却像让代码保持不变。由此而产生了在面向对象设计中需要考虑的一个基本问题：“如何把变动的事物与保持不变的事物区分开来”。

这对类库（library）而言尤为重要。该类库的消费者必须依赖他所使用的那部分类库，并且能够知道如果类库出现了新版本，它们并不需要改写代码。从另一个方面来说，类库的开发这必须有权限进行修改和改进，并确保客户代码不会因为这些改动而受到影响。

这一目标可以通过约定来达到。例如，类库开发者必须同一在改动类库中的类时不得删除任何现有方法，因为那样会破坏客户端程序员的代码。但是，与之相反的情况会更加几首。在有域（即数据成员）存在的情况下，类库开发者要怎样才能知道究竟都有那些域已经被客户端程序员所调用了呢？这对于方法仅为类的实现的一部分，因此并不想让客户端程序员直接使用的情况来说同样如此。如果程序开发者想要移除旧的实现而要添加新的实现时，结果将会怎样呢？改动任何一个成员都有可能破坏客户端程序员的代码。于是类库开发者会手脚被缚，无法对任何事物进行改动。

为了解决这一问题，Java提供了访问权限修饰词，以供类库开发人员像客户端程序员指明哪些是可用的，那些是不可用的。访问权限控制的登记，从最大权限到最小权限以此为：**public**、**protected**，包访问权限（没有关键词）和**private**。根据前述内容，读者可能会认为，作为一名类库设计院，你会尽可能将一切方法都定为**private**，而仅向客户端程序员公开你愿意让它们使用的方法。这样做是完全正确的，尽管对于那些经常使用别的语言（特别是C语言）编写程序并在访问事物时不受任何限制的人而言，这与它们的直觉相违背。到了本章末，读者将会信服Java的访问权限控制的价值。

不过，构建类库的概念以及对于谁有权限用该类库构建的控制问题都还是不完善的。其中仍旧存在着如果将构建捆绑到一个内聚的类库单元中的问题。对于这一点，Java用关键字**package**加以控制，而访问权限修饰词会因类是存在于一个相同的包，还是存在于一个单独的包而受到影响。为此，要开始学习本章，首先要学习如何将类库构建置于包中，然后就会理解访问权限修饰词的全部含义。

## 6.1 包：库单元
包内包含有一组类，它们在单一的名字空间之下被组织在一起。

例如，在Java的标准库发布中国呢有一个工具库，它被组织在java.util名字空间下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。

```java
:// access/FullQualification.java

public class FullQualification {
	public static void main(String[] args) {
		java.util.ArrayList list = new java.util.ArrayList();
	}
}
```

这立刻就使程序变得很冗长了，因此你可能想转而使用**import**关键字。如果你想要导入单个的类，可以在**import**语句中命名该类：

```java
//: access/SingleImport.java
import java.util.ArrayList;

public class SingleImport {
	public static void main(String[] args) {
		ArrayList list = new java.util.ArrayList();
	}
}
```

现在，就可以不用限定地使用ArrayList了。但是，这样做**java.util**中的吉他类仍旧是都不可用的。要想导入其中所有的类，只需要使用“*”，就像在本书剩余部分的示例中所看到的那样：

```java
import java.util.*;
```

我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。A类中的方法`f()`与B类中的具有相同特征标记（参数列表）的方法`f()`不会彼此冲突。但是如果类名相互冲突又该怎么办呢？假设你编写了一个`Stack`类并安装到了一台机器上，而该及其上已经有了一个别人编写的`Stack`类，我们该如何解决呢？由于名字之间的潜在冲突，在Java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情。

到目前为止，书中大多数示例都存与单个文件中，并专为本地使用（local use)而设计，因为尚未受到包名的干扰。这些示例实际上已经位于包中了：即*未命名包*，或成为*默认包*。这当然也是一种选择，而且为了简单期间，在本书其他部分都尽可能地使用了此方法。不过如果你正在准备编写对在同一台机器上共存的其他Java程序友好的类库或程序的话，就需要考虑如何防止类名称之间的冲突问题。

当编写一个Java源代码文件时，此文件通常成称为编译单元（有时也称为转译单元）。每个编译单元都必须有一个后缀名.Java，而在编译单元内则可以有一个**public**类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个**public**类，否则编译器就不会接受。如果在该编译单元这中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是**public**类，而且它们主要用来为主**public**提供支持。

### 6.1.1 代码组织
当编译一个.java文件时，在.java文件中的每个类都会有一个输出文件，而该输出文件的名称与.java文件中的每个类的名称相同，只是多了一个后缀名.class。因此，在编译少量.java文件之后，会得到大量的.class文件。如果用编译型语言编写过程序，那么对于编译器产生一个中间文件（通常是一个obj文件），然后再与通过链接器（用以创建一个可执行文件）或类库产生器（librarian，用于创建一个类库）产生的其他同类文件捆绑在一起的情况，可能早已司空见惯。但这并不少Java的工作方式。Java可运行程序是一组可以打包并压缩为一个Java文档文件（JAR，使用Java的jar文档生成器）的.class文件。Java解释器负责这些文件的查找、装载和解释。

类库实际上是一组类文件。其中每个文件都有一个**public**类，以及任意数量的非**public**类。因此每个文件都有一个构建。如果希望这些勾结（每一个都有它们自己独立的.java和.class文件）从属于同一个群组，就可以使用关键字**package**。

如果使用**package**语句，它必须是文件中除注释以外的第一句程序代码。在文件起始处写：

```java
package access;
```

就表示你在声明该编译单元是名为**access**的类库的一部分。或者换种说法，你正在声明该编译单元中的**public**类名称是位于**access**名称的保护伞下。任何想要使用该名称的人都必须使用前面给出的选择，指定全名或者与**access**结合使用关键字**import**。（请注意，Java包的命名规则全部使用小写字母，包括中间子也是如此。）


例如，假设文件的名称是**MyClass.java**，这就意味着该文件中有且只有一个**public**类，该类的名称必须是**MyClass**（注意大小写）：

```java
//: access/mypackage/MyClass.java
package access.mypackage;

public class MyClass{
	// ...
} ///:~
```

现在，如果有人想用**MyClass**或者是**access**中的任何其他**public**类，就必须使用关键字**import**来使**access**中的名称可用。另一种选择是给出完整的名称：

```java
//: access/QualifiedMyClass.java

public class QualifiedMyClass {
	public static void main(String[] args) {
		access.mypackage.MyClass m = new access.mypackage.MyClass();
	}
} ///:~
```

关键字**import**可使之更加简洁：

```java
//: access/ImportedMyClass.java
import access.mypackage.*;

public class ImportedMyClass {
	public static void main(String[] args) {
		MyClass m = new MyClass();
	}
} ///:~
```

身为一名类库设计员，很有必要牢记：**package** 和 **import** 关键字允许你做的，是将单一的全局名字空间分隔开，使得无论多少人使用Internet以及Java开始编写类，都不会出现名称冲突问题。

### 6.1.2 创建独一无二的包名
读者也许会发现，既然一个包从未真正将被打包的东西包装成单一的文件，并且一个包可以由许多.class文件构成，那么情况就有点复杂了。为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包的所有.class文件都至于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决这一问题。这是Java解决混乱问题的一种方式，读者还会在我们介绍jar工具的时候看到另一种方式。

将所有的文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称以及怎样查找有可能隐藏于目录结构中某处的类。这些任务是通过将.class文件所在的路径位置编码成**package**的名称来实现的。按照管理，package名称的第一部分是类的创建者的翻顺序的Internet域名。如果你遵照管理，Internet域名应是独一无二的，因此你的package包名也将是独一无二的，也就不会出现名称冲突的问题了（也就是说，只有在你将自己的域名给了别人，而他又以你曾经使用过的路径名称来编写Java程序代码时，才会出现冲突）。当然，如果你没有自己的域名，你就得构造一组不大可能与他人重复的组合（例如你的姓名），来创建独一无二的package名称。如果你打算发布你的Java程序代码，稍微花点力气去取得一个郁闷，还是很有必要的。

此技巧的第二部分是把package名称分解为你机器上的一个目录。所以当Java程序运行并且需要价值.class文件的时候，它就可以确定.class文件在目录上所处的位置。

Java解释器的运行过程如下：首先，找出环境变量CLASSPATH（可以通过操作系统来设置，有时也可以通过安装程序-用来在你的机器上安装Java或基于Java的工具来设置）。CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，已从CLASSPATH根中产生一个路径名称。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。

为了理解这一点，以我的域名**MindView.net**为例。把他的顺序倒过来，并且将器全部转换为小写，**net.mindview**就成了我所创建的类的独一无二的全局名称。（com、edu、org等扩展名先前在Java包中都是大写的，但在Java2中一切都已改观，包的整个名称全都变成了小写。）若我决定在创建一个名为simple的类库，我可以将该名称进一步细分，于是我可以得到一个包的名称如下：

```java
package net.mindview.simple;
```

现在，这个包名就可以用作下面两个文件的名字空间保护伞了：

```java
//: net/mindview/simple/Vector.java
// Create a package.
package net.mindview.simple;

public class Vector {
	public Vector() {
		System.out.println("net.mindview.simple.Vector");
	}
} ///:~
```

如前所述，package语句必须是文件中的第一行非注释程序代码。第二个文件看起来也极其相似：

```java
//: net/mindview/simple/List.java
// Create a package.
package net.mindview.simple;

public class List {
	public List() {
		System.out.println("net.mindview.simple.List");
	}
} ///:~
```

这两个文件军备置于我的系统的子目录下：

```
C:\DOC\JavaT\net\mindview\simple
```

请注意，在本书的每一个文件中的第一行注释都指定了该文件在源代码目录树中的为止，这个信息将针对本书的自动代码抽取工具使用。

如果沿此路径往回看，可以看到包的名称**com.bruceeckel.simple**，但此路径的第一部分怎样办呢？它将由环境变量CLASSPATH关照，在我的机器上是：

```
CLASSPATH=.;D:\JAVA|LIB;C:\DOC\JavaT
```

可以看到，CLASPATH可以包含多个可供选择的查询路径。

但在使用JAR文件时会有一点变化。必须在类路径中将JAR文件的实际名称写清楚，而不仅是指明它所在位置的牡蛎。因此，对于一个名为grape.jar的文件，类路径应包括：

```
CLASSPATH=.;D:\JAVA\LIB;C:\flavors\grape.jar
```

一旦类路径得以正确建立，下面的文件就可以放于任何目录之下：

```java
//: access/LibTest.java
// Uses the library.
import net.mindview.simple.*;

public class LibTest {
	public static void main(String[] args) {
		Vector v = new Vector();
		List l = new List();
	}
} /* Output:
net.mindview.simple.Vector
net.mindview.simple.List
*///:~
```

当编译器碰到simple库的import语句时，就开始哎CLASSPATH所指定的目录中查找，查找子目录**net\mindview\simple**，然后从一编译的文件中找出名称相符者（对**Vector**而言是Vector.class，对**List**而言是List.class）。请注意，Vector和List中的类以及要使用的方法都必须是public的。

对于使用Java的新手而言，设立CLASSPATH是很麻烦的一件事（我最初使用时就是这样的）；为此，Sun将Java2中的JDK改造的更聪明一些。在安装后你会发现，即使你未设计CLASSPATH，你也可以编译并运行基本Java程序。然后，要编译和运行本书的源码包，就得想你的CLASSPATH中添加本书程序代码中的基目录了。

**冲突**

如果将两个含有相同名称额类库以“*”的形式导入，将会出现什么情况呢？ 例如，假设某程序这样写：
```
import net.mindview.simple.*;
import java.util.*;
```

由于java.util.*包含了一个Vector类，这就存在潜在的冲突。但是只要你不写那些导致冲突的程序代码，就不会有什么问题——这样很好，否就得做很多类型检查工作来防止那些根本不会出现的冲突。

如果现在要创建一个**Vector**类的话，机会产生冲突：

```java
Vector v = new Vector();
```

这行到期取用的是哪个Vector类？编译器不知道，读者同样也不知道。于是编译器提出错误信息，强制你明确指明。举例说明，如果想要一个标准的Java Vector类，就得这样写：

```java
java.util.Vector v = new java.util.Vector();
```

由于这样可以完全指明该Vector类的为止（配置CLASSPATH），所以除非还要使用java.util中的其他东西，否则句没有必要写import java.util.*语句了。

或者，可以使用单个类导入的形式防止冲突，只要你在同一个程序中没有使用冲突的名字。

### 6.1.3 定制工具库
具备了这些知识以后，现在就可以创建自己的工具库来减少或消除重复的程序代码了。例如，我们已经用到的`System.out.println()`的别名可以减少输入负担，这种机制可以用于名为Print的类中，这样，我们在使用该类的时候可以用一个更加具有可读性的静态**import**语句来导入。

```java
//: net/mindview/util/Print.java
// Print methods that can be used without
// qualifiers. using Java SE5 static imports:
package net.mindview.util;

import java.io.*;

public class Print{
	// Print with a newline:
	public static void print(Object obj) {
		System.out.println(obj);
	}

	// Print a newline by itself:
	public static void print() {
		System.out.println();
	}

	// Print with no line break:
	public static void printnb(Object obj) {
		System.out.print(obj);
	}


	// The new Java SE5 printf() (from C):
	public static PrintStream printf(String format, Object... args) {
		return System.out.printf(format, args);
	} 
} ///:~
```

可以使用打印便捷工具来打印String，无论是需要缓缓（print()）还是不需要缓缓（printnb()）。

可以才到，这个文件的位置一定是在某个以一个CLASSPATH位置开始，然后接着是net/mindview的目录下。编译完之后，就可以用`import static` 语句在你的系统上使用静态的`print()`和`printnb()`方法了。

```java
//: access/PrintTest.java
// Uses the static printing methods in Print.java
import static net.mindview.util.Print.*;

public class PrintTest {
	public static void main(String[] args) {
		print("Available from now on!");
		print(100);
		print(100L);
		print(3.14159);
	}
} /* Output:
Available from now on!
100
100
3.14159
*///:~
```

这个类库的第二个构建可以是在第4章中引入的`range()`方法，它使得foreach语法可以用于简单的整数序列：

```java
//: net/mindview/util/Range.java
// Array creation methods that can be used without
// qualifiers. using Java SE5 static imports:
package net.mindview.util:

public class range {
	// Produce a sqquence [0..n)
	public static int[] range(int n) {
		int[] result = new int[n];
		for (int i = 0; i < n; i++) {
			result[i] = i;
		}
		return result;
	}

	// Produce a sequence [start, end)
	public static int[] range(int start, int end) {
		int sz = end - start;
		int[] result = new int[sz];
		for (int i = 0; i < sz; i++) {
			result[i] = start + i;
		}
		return result;
	}

	// Produce a sequence [start, end) incrementing by step
	public static int[] range(int start, int end, int step) {
		int sz = (end - start) / step;
		int[] result = new int[sz];
		for (int i = 0; i < sz; i++) {
			result[i] = start + (i * step);
		}
		return result;
	}
} ///:~
```

从现在开始，你无论何时创建了有用的新工具，都可以将其添加到你自己的类库中。你将看到本书中还有更多的构建添加到了**net.mindview.util**类库中。

### 6.1.4 用import改变行为
Java没有C的条件编译功能，该功能可以使你不必更改任何程序代码，就能够切换开馆并产生不同的行为。Java去掉此功能的原因可能是因为C在绝大多数情况下是用此功能来解决跨平台问题的，即程序代码的不同部分是根据不同的平台来编译的。由于Java自身可以自动跨越不同的平台，因此这个功能对Java而言是没有必要的。

然后，条件编译还有其他一些有价值的用途。调试就是一个很常见的用途。调试功能在开发过程中是开启的，而在发布的产品中是禁用的。可以通过修改被导入的package的方法来实现这一目的，修改的方法是将你程序中用到的代码从调试版该为发布板。这一技术可以适用于任何种类的条件代码。

### 6.1.5 对使用包的忠告
无比记住，无论何时创建包，都已经在给定包的名称的时候隐含地指定了目录结构。这个包必须位于其名称所指定的目录之中，而该目录必须是在以CLASSPATH开始的目录中开始查询到的。最初使用关键字**package**，可能会有一点不顺，因为除非遵守“包的名称对应目录路径”的规则，否则将会收到许多出乎意料的运行时信息，告知无法找到指定的类，哪怕是这个类就位于同一目录之中。如果你收到类似信息，就用注释调package语句的方式试一下，如果这样程序就能运行的话，你就可以知道问题出在哪里了。

注意，编译过的代码通常放置在于源代码的不同目录中，但是必须保重JVN使用CLASSPATH可以找到该路径。

## 6.2 Java访问权限修饰词
**public**、**protected**和**private**这几个Java访问权限修饰词在使用时，是置于类中每个成员的定义之前的————无论它是一个域还是一个方法。每个访问权限修饰词仅控制它所修饰的特定定义的访问权。

如果不提供任何权限修饰词，则意味着它是“包访问权限”。因此，无论如何，所有事物都具有某种形式的访问权限控制。在以下几节中，读者将学习各种类型的访问权限。

### 6.2.1 包访问权限
本章之前的所有示例都没有使用任何访问权限修饰词。默认访问权限没有任何关键字，但通常是指包访问权限（有时也表示成为friendly）。这就意味着当前的包中的所有其他类对那个成员都有访问权限，仅对于这个包之外的所有类，这个成员却是**private**。由于一个编译单元（即一个文件），只能隶属于一个包，所以经由包访问权限，处于同一编译单元中的所有类批次之前都是自动可访问的。

包访问权限允许将包内所有相关的类组合起来，以使它们批次之间可以轻松地相互作用。当把类组织起来放进一个包内之时，也就给它们的包访问权限的成员赋予了相互访问的权限，你“拥有”了该包内的程序代码。“只有你拥有的程序代码才可以访问你所拥有的其他程序代码”。这是合理的。应该说，包访问权限为把类群聚在一个包中的作坊提供了意义和理由。在许多语言中，在文件内组织定义的方式是任意的，但在Java中，则要强制你以一种合理的方式对它们加以组织。另外，你可能还想要排除这样的类————它们不应该访问在当前包中所定义的类。

类控制着那些代码有权访问自己的成员。其他包内的类不能刚一上来就说：“嗨。我是Bob的朋友。”并且还想看到Bob的protected、包访问权限和private成员。取得对成员的访问权的唯一途径是：

1. 使该成员成为public。于是，无论是谁，无论在哪里，都可以访问该成员。
2. 通过不加访问权限修饰词并将其他类放置于同一个包内的方式给成员赋予包访问圈。于是包内的其他类也就可以访问该成员了。
3. 第7章将会介绍集成技术，届时读者将会看到继承而来的类既可以访问public成员也可以访问protected成员（但访问private成员却不行）。只有在两个类都处于同一个包内时，它才可以访问包访问权限的成员。但现在不必担心继承和protected。
4. 提供访问器（accessor）和变异器（mutator）方法（也称作get/set方法），以读取和改变树枝。

### 6.2.2 public：接口访问权限
使用关键字**public**，就意味着public之后紧跟着的成员声明自己对每个人都是可用的，尤其是使用类库的客户程序员更是如此。假设定义了一个包含下面编译单元的dessert包：

```java
//: access/dessert/Cookie.java
// Creates a library.
package access.dessert;

public class Cookie {
	public Cookie() {
		System.out.println("Cookie constructor");
	}
	void bite() {
		System.out.println("bite");
	}
} ///:~
```

记住，**Cookie.java**文件必须位于名为dessert的子目录之中，该子目录在access下，而c05必须位于CLASSPATH指定的众多路径的其中之一的下面。不要错误滴认为Java总是将当前目录视作是查找行为的起点之一。如果你的CLASSPATH之中缺少一个“.”作为路径之一的化，Java就不会查找那里。

现在如果创建了一个使用Cookie的程序：

```java
//: access/Dinner.java
// Uses the library.
import access.dessert.*;

public class Dinner {
	public static void main(String[] args) {
		Cookie x = new Cookie();
		//! x.bite();  // Can't access
	}
} /* Output:
Cookie constructor
*///:~
```

就可以创建一个Cookie对象，因为他的构造器是public而且类也是public的。但是，由于`bite()`只向在dessert包中的类提供访问权，所以`bite()`成员在Dinner.java之中是无法访问的，因此编译器也禁止你使用它。

**默认包**

令人吃惊的是，下面的程序代码虽然看起来破坏了上述规则，但它仍可以编译：

```java
//: access/Cake.java
// Accesses a class in a separate compilation unit.

class Cake {
	public static void main(String[] args) {
		Pie x = new Pie();
		x.f();
	}
} /* Out put:
Pie.f();
*///:~
```

在第二个处于相同目录的文件中：

```java
//: access/Pie.java
// The other class.
class Pie {
	void f() {
		System.out.println("Pie.f()");
	}
} ///:~
```

最初或许胡认为这两个文件毫不相关，但Cake却可以创建一个Pie对象并调用他的`f()`方法！通常会认为**Pie**和`f()`想有包访问权限，因而是不可以为Cake使用。他们的却想有包访问权限，但这只是部分正确的。Cate.java可以访问他们的原因是因为它们处于相同的目录并且没有给自己设定任何包名称。Java将这样的文件自动看作是隶属于该目录的默认包之中，于是它们为该目录中所有其他文件都提供了包访问权限。

### 6.2.3 private：你无法访问
关键字**private**的意思是，除了包含该成员的类之外，其他任何类都无法访问这个成员。由于处于同一个包内的其他类是不可以访问private成员的，因此这等于说是自己隔离了自己。从另一方面说，让许多人共同合作来创建一个包也是不大可能的，为此priate就允许你随意改变该成员，而不必考虑这样做释放会影响到包内其他的类。

默认的包访问权限通常已经提供了充足的隐藏措施。请记住，使用类的客户端程序员是无法访问包访问权限成员的。这样做很好，因为默认访问权限是一种我们常用的权限，同时也是一种在忘记添加任何访问权限控制时能够自动得到的权限。因此，通常考虑的是，哪些成员是想要明确公开给客户端程序员使用的，从而将它们声明为public，而在最初，你可能不会认为自己经常用需要使用关键字private，因为没有它，照样可以工作。然而，实施很快就会证明，对private的使用是多么的重要，在多线程环境下更是如此

此处有一个使用private的示例：
```java
//: access/IceCream.java
// Demonstrates 'private' keyword.

class Sundae {
	private Sundae() { }

	static Sundae makeASundae() {
		return new Sundae();
	}
}

public class IceCream {
	public static void main(String[] args) {
		//~ Sundae x = new Sundae();
		Sundae x = Sundae.makeASundae();
	}
} ///:~
```

这是一个说明private终有其用武之地的示例：可能想控制如何创建对象，并阻止别人直接访问某个特定的构造器。在上面的例子中，不能通过构造器来创建Sundae对象，而必须调用`makeASundae()`方法来打到此目的。

任何可以肯定只是该类的一个“助手”方法的方法，都可以把它指定为private，以确保不会在包内的其他地方误用到它，于是也就防止了你会去改变或删除这个方法。将方法指定为private
确保了你拥有这种选择权。

这对于类中的private域同样适用。除非必须公开底层实现细目，否则就应该将所有域指定为private。然后，不能因为在类中某个对象的引用是private，就认为其他对象无法拥有该对象的public引用。

### 6.2.4 protected：继承访问权限
要理解protected的访问权限，我们在内容上需要做一点跳跃。首先，在本书介绍继承之前，读者并不需真正理解本节的内容。但为了内容的完整性，这里还是提供了一个简要的介绍和使用protected的示例

关键字protected处理的是继承的概念，通过继承可以利用一个现有类，我们将其成为基类，然后将新成员添加到该现有类中而不必碰现有类。还可以改变现有成员的行为。为了从现有类中继承，需要声明新类extends了一个现有类，就像这样：

```java
class Foo extends Bar {}
```

类定义中的其他部分看起来都是一样的。

如果创建了一个新包，并自另一个包中继承类，那么唯一可以访问的成员就是源包的public成员。
