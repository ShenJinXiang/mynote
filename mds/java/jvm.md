# jvm

## 整数在Java虚拟机中的比阿诗

原码 -- 符号位加上数字的二进制表示

对于原码来说，绝对值相同的正数和负数只有符号位不同

反码 -- 在原码的基础上，符号位不变，其余位取反

补码 -- 负数的补码就是反码加1，整数的补码就是原码本身


### 使用补码作为计算机内存储方式的好处

1. 可以统一数字0的表示，不管作为正数还是负数，用补码表示都正确
2. 使用补码可以简化整数的加减法计算

## java虚拟机基本结构
```
    |----------------------------------|                           |------------------|
    |            类加载系统            |                           |      Java栈      |
    |----------------------------------|                           |------------------|

    |--------------|    |--------------|    |----------------|     |------------------|
    |    方法区    |    |    Java堆    |    |    直接内存    |     |    本地方法栈    |
    |--------------|    |--------------|    |----------------|     |------------------|
	
    |--------------------------------------------------------|     |------------------|
    |                      垃圾回收系统                      |     |     PC寄存器     |
    |--------------------------------------------------------|     |------------------|

    |---------------------------------------------------------------------------------|
    |                                     执行引擎                                    |
    |---------------------------------------------------------------------------------|
```

* 类加载系统负责从文件系统或网络中加载Class信息，加载的类信息存放于一块方法区的内存空间
* Java堆在虚拟机启动的时候建立，是Java程序最主要的内存工作区域
* 堆空间是所有线程共享的
* 直接内存是在Java堆外的，直接向系统申请的内存区间，访问直接内存的速度会优于Java堆
* 垃圾回收器可以堆方法区、java堆和直接内存进行回收
* 每个Java虚拟机线程都有一个私有的Java栈，在线程创建的时候被创建，保存局部变量、方法参数，于java方法的调用、返回相关
* 本地方法是java虚拟机的重要扩展，允许java直接调用本地方法
* PC寄存器是每个线程私有的空间
* 执行引擎是Java虚拟机的最核心组件之间，负责执行虚拟机的字节码

## java 命令
> java [-options] class [args...]

* -options java虚拟机启动参数
* class 为带有main()函数的Java类
* args表示传递给主函数main()的参数

**例子**

```java
public class SimpleArgs {

	public static void main(String[] args) {
		for (int i = 0; i < args.length; i++) {
			System.out.println("参数" + (i + 1) + ": " + args[i]);
		}
		System.out.println("-Xmx" + Runtime.getRuntime().maxMemory() / 1000 / 1000 + "M");
	}
}
```

编译运行：
```
$ javac SimpleArgs
$ java -Xmx100m SimpleArgs aa bb cc
参数1: aa
参数2: bb
参数3: cc
-Xmx100M
 ```

## Java堆
Java堆是Java应用程序关系最密切的内存空间，几乎所有的对象都存放在堆中，通过垃圾回收机制管理java堆

Java堆分为新生代和老年代。新生代存放新生对象或者年龄不大的对象，老年代存放老年对象。

新生代分为eden区、s0区、s1区。s0和s1区是大小相等、可以互换角色的内存空间

对象首先分配在eden区，在一次新生代回收后，如果对象存活，会进入s0或s1区，之后每经历一次新生代回收，对象如果存活，年龄加1，当对象年龄达到一定条件后，会被认为是老年对象，进入老年代

## java栈
java栈是线程的一块私有内存空间，先进后出的数据结构，支持出栈和入栈两种操作

java栈种保存的主要内容为栈帧，每次函数调用都会有对应的栈帧压入java栈中，每一个java函数结束，都会有一个栈帧被弹出java栈。

由于每次函数调用都会生成对应的栈帧，从而占用一定的栈空间，如果栈空间不足，那么函数的调用自然无法继续进行下去，当请求的栈深度大于最大可用栈深度时，系统跑出StackOverflowError异常

java虚拟机提供了-Xss来指定线程最大栈空间，这个参数直接决定了函数调用的最大深度

### 局部变量表
局部变量表是栈帧的重要组成部分，用于保存函数的参数及局部变量，局部变量表中的变量只在当前函数的调用中有效，调用结束后，随着函数栈帧销毁，局部变量表也随之销毁

由于局部变量在栈帧之中，如果函数的参数和局部变量较多，会使得局部变量表膨胀，每次调用函数就会占用更多的栈空间，导致函数的嵌套次数减少，即相同栈空间下，局部变量少的函数可以支持更深的函数调用。


```java
public class TestStackDeep {
	
	private static int count = 0;

	public static void recursion() {
		count++;
		recursion();
	}

	public static void recursion(long a, long b, long c) {
		long e = 1L,
			 f = 2L,
			 g = 3L,
			 h = 4L,
			 i = 5L,
			 j = 6L,
			 k = 7L,
			 l = 8L,
			 m = 9L,
			 n = 10L;
		count++;
		recursion(a, b, c);
	}

	public static void main(String[] args) {
		try {
			recursion();
			// recursion(1L, 1L, 1L);
		} catch (Throwable e) {
			System.out.println("deep : " + count);
		}
	}
}
```

### 帧数据区
除了局部变量表和操作数栈外，java栈帧还需要一些数据来支持常量池解析、正常方法返回和异常处理等。在帧数据区中保存着访问常量池的指针，方便程序访问常量池

当函数返回或者出现异常时，虚拟机必须恢复调用者函数的栈帧，并让调用者函数继续执行下去。对于异常处理，虚拟机必须又一个异常沪成立表，方便在发生异常的时候找到处理异常的代码，异常处理表也是帧数据区中重要的一部分

### 栈上分配
栈上分配是java虚拟机提供的一项优化技术：对于那些线程私有的对象，可以将它们打散分配在栈上，而不是分配在堆上，可以在函数调用结束后自行销毁，而不需要垃圾回收器介入，提高系统的性能

栈上分配的技术基础是进行逃逸分析，判断对象的作用域是否有可能逃逸出函数体

```java
// 逃逸的对象
private static User u;

public static void alloc() {
	u = new User();
	u.id = 5;
	u.name = "geym";
}
```

## 方法区
方法区是一块所有线程共享的内存区域，用于保存系统的类信息，比如类的字段、方法、常量池等

方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的列，导致方法区溢出，虚拟机同样会抛出内存溢出错误


