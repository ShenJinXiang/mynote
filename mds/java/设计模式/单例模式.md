# 单例模式

单例模式(Singleton pattern) 是一种常见的设计模式，用于确保在整个系统中只有一个实例对象，单例模式有三个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例

## 定义
在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例

## 饿汉式单例
饿汉式单例是实现起来最简单的单例，代码：
```javascript
public class EagerSingleton {
	
	private static EagerSingleton instance = new EagerSingleton();

	private EagerSingleton() { }

	public static EagerSingleton getInstance() {
		return instance;
	}

	// 其他代码...

	// 简单测试
	public static void main(String[] args) {
        EagerSingleton eagerSingleton1 = EagerSingleton.getInstance();
        EagerSingleton eagerSingleton2 = EagerSingleton.getInstance();
        System.out.println(eagerSingleton1 == eagerSingleton2);
    }
}
```
*运行结果：*
```
true
```
当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建

## 懒汉式单例
不同于饿汉式单例，懒汉式单例在首次调用`getInstance()`方法的时候才会创建实例对象
```java
public class LazySingleton {

	private static LazySingleton instance = null;

	private LazySingleton() { }

	public static LazySingleton getInstance() {
		if (instance == null) {
			instance = new LazySingleton();
		}
		return instance;
	}

	// 其他代码...
}
```

懒汉式单例存在着线程安全问题，当第一次调用`getInstance()`方法时，`instance`对象为`null`值，因此将执行代码`instance= new LazySingleton()`，在此过程中，如果要对`LazySingleton`进行大量初始化工作，需要一段时间来创建`LazySingleton`对象。而在此时，如果再一次调用`getInstance()`方法（通常发生在多线程环境中），由于`instance`尚未创建成功，仍为`null`值，判断条件`(instance== null)``为真值，因此代码`instance = new LazySingleton()`将再次执行，导致最终创建了多个`instance`对象，这违背了单例模式的初衷，也导致系统运行发生错误
