# 设计模式

## UML 类图
* 泛化关系（generalization） 用一条带空心箭头的直接表示，A指向B表示，A继承自B
* 实现关系（realize） 用一条带空心箭头的虚线表示 A指向B表示，A实现了B，B应该为一个接口活抽象类
* 聚合关系（aggregation） 用一条带空心菱形箭头的直线表示 A指向B，A聚合到B上，B由A组成
* 组合关系（composition） 用一条带实心菱形箭头直线表示
* 关联关系（association） 用一条直线表示
* 依赖关系（dependency） 一套带箭头的虚线表示的

## 列表
1. [面向对象设计原则](./面向对象设计原则.md#面向对象设计原则)    
2. [单例模式](./单例模式.md#单例模式)    
3. [简单工厂模式](./简单工厂模式.md#简单工厂模式)    
4. [工厂方法模式](./工厂方法模式.md#工厂方法模式)
5. [外观模式](./外观模式.md#外观模式)    
6. [适配器模式](./适配器模式.md#适配器模式)    
7. [模板方法模式](./模板方法模式.md#模板方法模式)    
8. [抽象工厂模式](./抽象工厂模式.md#抽象工厂模式)    
8. [组合模式](./组合模式.md#组合模式)    


## 学习顺序

|学习顺序|     设计模式   |常用程度|   适用层次   |   引入时机   |结构复杂度|       变化       |          实现          | 体现的原则 |
|-------:|:---------------|:------:|:-------------|:-------------|:---------|:-----------------|:-----------------------|:-----------|
|1       |Factory Method  |很常用  |代码级        |编码时        |简单      |子类的实例化      |对象的创建工作延迟到子类|开闭原则    |
|2       |Singleton       |很常用  |代码级、应用级|设计时、编码时|简单      |唯一实例          |封装对象产生的个数      |            |
|3       |Facade          |很常用  |应用级、构架级|设计时、编码时|简单      |子系统的高层接口  |封装子系统              |开闭原则    |
|4       |Template Method |很常用  |代码级        |编码时、重构时|简单      |算法子步骤的变化  |封装算法结构            |依赖倒置原则|
|5       |Abstract Factory|比较常用|应用级        |设计时        |比较复杂  |产品家族的扩展    |封装产品族系列内容的创建|开闭原则    |
|6       |Composite       |比较常用|代码级        |编码时、重构时|比较复杂  |复杂对象接口的统一|统一复杂对象的接口      |里氏代换原则|
|7       |Proxy           |比较常用|应用级、构架级|设计时、编码时|简单      |对象访问的变化    |封装对象的访问过程      |里氏代换原则|
|8       |Command         |比较常用|应用级        |设计时、编码时|比较简单  |请求的变化        |封装行为对对象          |开闭原则    |
|9       |Observer        |比较常用|应用级、构架级|设计时、编码时|比较简单  |通讯对象的变化    |封装对象通知            |开闭原则    |
|10      |Strategy        |比较常用|应用级        |设计时        |一般      |算法的变化        |封装算法                |里氏代换原则|
|11      |Builder         |一般    |代码级        |编码时        |一般      |对象组建的变化    |封装对象的组建过程      |开闭原则    |
|12      |Adapter         |一般    |代码级        |重构时        |一般      |对象接口的变化    |接口的转换              |            |
|13      |Bridge          |一般    |代码级        |设计时、编码时|一般      |对象的多维度变化  |分离接口以及实现        |开闭原则    |
|14      |Decorator       |一般    |代码级        |重构时        |比较复杂  |对象的组合职责    |在稳定接口上扩展        |开闭原则    |
|15      |Iterator        |一般    |代码级、应用级|编码时、重构时|比较简单  |对象内部集合的变化|封装对象内部集合的使用  |单一职责原则|
|16      |Mediator        |一般    |应用级、构架级|编码时、重构时|一般      |对象交互的变化    |封装对象间的交互        |开闭原则    |
|17      |Memento         |一般    |代码级        |编码时        |比较简单  |状态的辅助保存    |封装对象状态的变化      |接口隔离原则|
|18      |State           |一般    |应用级        |设计时、编码时|一般      |对象状态的变化    |封装与状态相关的行为    |单一职责原则|
|19      |Visitor         |一般    |应用级        |设计时        |比较复杂  |对象操作变化      |封装对象操作变化        |开闭原则    |
|20      |Prototype       |不太常用|应用级        |编码时、重构时|比较简单  |实例化的类        |封装对原型的拷贝        |依赖倒置原则|
|21      |Flyweight       |不太常用|代码级、应用级|设计时        |一般      |系统开销的优化    |封装对象的获取          |            |
|22      |Chain of Resp   |不太常用|应用级、构架级|设计时、编码时|比较复杂  |对象的请求过程    |封装对象的责任范围      |            |
|23      |Interpreter     |不太常用|应用级        |设计时        |比较复杂  |领域问题的变化    |封装特定领域的变化      |            |
